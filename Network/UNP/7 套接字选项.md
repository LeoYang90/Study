# 套接字选项

## 1、SO_KEEPALIVE 套接字会对对端发送探测分节，发送后会有哪些情况？

- 对端以期望的 `ACK` 响应
- 对端以 `RST` 响应：对端已崩溃并且已经重新启动
- 对端无任何响应：对端主机已经崩溃（非进程崩溃，否则会受到 `FIN`）或者网络不可达。如果根本没有响应，那么错误就是 `ETIMEOUT`，如果收到了 `ICMP` 错误响应，那么就是相应的错误，最常见的是 `EHOSTUNREACH`.

本选项一般是服务端设置，用来检测客户端是否崩溃。

## 2、SO_LINGER 套接字选项的作用是什么？

- 当调用 `close` 函数后，默认操作是 `close` 函数立刻返回，系统会尝试把残留的数据发送到对端，但是并不保证对端会接受成功。
- 当设置了 `SO_LINGER` 后，分为三种情况：
    - `l_onoff` 为 0：默认 TCP 设置，close 立刻返回
    - `l_onoff` 非0， `l_linger` 均为 0：TCP 将会立刻丢弃残留数据，并发送 RST 给对端
    - `l_onoff` 与 `l_linger` 均为非 0：
        - 残留数据全部发送完，数据和 `FIN` 已被服务端确认
        - 延滞时间到，`close` 会返回 `EWOULDBLOCK`，套接字残留数据被丢弃

## 3、`SO_RCVBUF`、`SO_SNDBUF` 套接字选项的作用？

设置发送缓冲区与接收缓冲区的大小。
相应的：

- `SO_RCVLOWAT`、`SO_SNDLOWAT` 接收低水位标记与发送低水位标记
- `SO_RCVTIMEO`、`SO_SNDTIMEO` 接收和发送超时值

## 4、`SO_REUSEADDR` 与 `SO_REUSEPORT` 套接字选项的作用？

- `SO_REUSEADDR` 允许启动一个监听服务器并捆绑其众所周知的端口，即使以前建立的将该端口作为它们的本地端口的连接仍然存在。
- `SO_REUSEADDR` 允许在一个端口上绑定统一服务器的多个实例，只要不同的本地 IP 地址即可。
- `SO_REUSEADDR` 允许单个进程捆绑同一端口到多个套接字上，只要指定不同的本地 IP 地址即可
- `SO_REUSEADDR`允许完全重复的绑定：如果传输协议允许（一般指的是 UDP），相同的 ip 地址和端口号可以绑定在不同的套接字上。

## 5、`TCP_NODELAY` 套接字选项的作用？

`Nagle` 算法主要是避免发送小的数据包，要求 `TCP` 连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，`TCP` 收集这些少量的小分组，并在确认到来时以一个分组的方式发出去。

在默认的情况下, `Nagle` 算法是默认开启的，`Nagle` 算法比较适用于发送方发送大批量的小数据，并且接收方作出及时回应的场合，这样可以降低包的传输个数。当应用不是连续请求+应答的模型的时候，而是需要实时的单项的发送数据并及时获取响应，这种case就明显不太适合 `Nagle` 算法，明显有 `delay` 的。

`Nagle` 算法常常与另外一个 TCP 算法联合使用：`ACK` 延滞算法。该算法使得 TCP 在接受到数据后不立即发送 `ACK`，而是等待一小段时间才发送 `ACK`。






## API

```
int getsockopt(int sockfd,int level,int option,void *restrict optval,socklen_t restrict optlen);
int setsockopt(int sockfd,int level,int option,const void *optval,socklen_t optlen);

struct linger {
    int l_onoff;
    int l_linger;
}
```