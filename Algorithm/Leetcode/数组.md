# 数组

## 合并数组

### 4. 寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

```

核心代码

```
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int size1 = nums1.size();
    int size2 = nums2.size();
    int sum = size1 + size2;
    
    int mid = 0;
    if (sum % 2 == 1) mid = (sum + 1) / 2;
    if (sum % 2 == 0) mid = sum / 2;
    
    int index = 0, index1 = 0, index2 = 0;
    double res = 0;
    while (index1 < size1 && index2 < size2)
    { 
        int tmp = 0;
        if (nums1[index1] <= nums2[index2])
        {
            tmp = nums1[index1];
            index1++;
        }
        else
        {
            tmp = nums2[index2];
            index2++;
        }
        
        if (index == (mid - 1)) {
            res += tmp;
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += tmp; res /= 2; return res;}
        
        index++;
    }
    
    while (index1 < size1)
    {
        if (index == (mid - 1)) {
            res += nums1[index1];
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += nums1[index1]; res /= 2; return res;}
        
        index1++;
        index++;
    }
    
    while (index2 < size2)
    {
        if (index == (mid - 1)) {
            res += nums2[index2];
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += nums2[index2]; res /= 2; return res;}
        
        index2++;
        index++;
    }
    
    return res;
}

```

关键点

> 本题需要注意的是中位数的位置是 (sum + 1)/2
> 
> 当偶数个数的时候，中位数位置是 mid-1,mid

### 56. 合并区间

给出一个区间的集合，请合并所有重叠的区间。

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

```

```
vector<Interval> merge(vector<Interval>& intervals) {
    if (intervals.size() <= 1) return intervals;
    
    std::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b) {
        return a.start < b.start;
    });
    
    vector<Interval> tmp = {intervals[0]};
    for (int i = 1; i < intervals.size(); i++)
    {
        Interval pre = tmp[tmp.size() - 1];
        Interval cur = intervals[i];
        
        if (pre.end >= cur.start && pre.end <= cur.end)
        {
            tmp[tmp.size() - 1].end = cur.end;
        }
        else if (pre.end < cur.start)
        {
            tmp.push_back(cur);
        }
    }
    
    return tmp;
}

```

关键点

> 排序之后，只需要关心前一个元素的 end 坐标在后一个元素的 start~end 范围关系
> 
> 如果在 start 之前，直接压入队列
> 
> 如果在 start~end 之间，修改前一个元素的 end 坐标
> 
> 如果在 end 之后，略过该元素。

### 57. 插入区间

给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）.

```
输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
输出: [[1,5],[6,9]]

```
	

```
vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
    vector<Interval> res = {newInterval};
    if (intervals.size() < 1) return res;
    
    vector<Interval> preSe;
    vector<Interval> postSe;
    for (int i = 0; i < intervals.size(); i++)
    {
        Interval cur = intervals[i];
        
        if (cur.end < newInterval.start)
        {
            preSe.push_back(cur);
        }
        else if (cur.start > newInterval.end)
        {
            postSe.push_back(cur);
        }
        else
        {
            if (cur.start < newInterval.start)
                newInterval.start = cur.start;
            
            if (cur.end > newInterval.end)
                newInterval.end = cur.end;
        }
    }
    
    res = preSe;
    res.push_back(newInterval);
    for (int i = 0; i < postSe.size(); i++)
        res.push_back(postSe[i]);
    
    return res;
}

```

关键点

> 重心在 newInterval 的范围
> 
> 当前元素如果不在 newInterval 的范围内，那么直接压入队列
> 
> newInterval 的 start 坐标在 cur 元素范围内，修改 newInterval 的 start
> 
> 类似地，newInterval 的 end 坐标在 cur 元素范围内，修改 newInterval 的 end

## 二分查找

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```
int searchInsert(int* nums, int numsSize, int target) {
    if (numsSize == 0) return 0;
    if (numsSize == 1 && nums[0] < target) return 1;
    
    int left = 0, right = numsSize - 1;
    
    int mid = 0;
    while (left <= right)
    {
        mid = (left + right) / 2;
        
        if (nums[mid] < target) left = mid + 1;
        if (nums[mid] > target) right = mid - 1;
        if (nums[mid] == target) return mid;
        
    }
    
    return left;
}

```

关键点

> 本题是标准的二分查找代码
> 
> 注意 left right 等初值的设定
> 
> 注意 while(l <= r) 的设定，一般来说，写成 l < r 也不会有大问题，无非返回的只能是 l， 而不能是 mid。
> 
> 但是在本题中需要找出插入点，那么就需要等于。
> 
> 注意返回的是 left

### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。



```
vector<int> searchRange(vector<int>& nums, int target) {
    vector<int> res = {-1, -1};
    
    int leftindex = extremeInsertionIndex(nums, target, 1);
    
    if (leftindex == nums.size() || nums[leftindex] != target)
    {
        return res;
    }
    
    res[0] = leftindex;
    
    int rightindex = extremeInsertionIndex(nums, target, 2);
    res[1] = rightindex;
    
    return res;
}
    
int extremeInsertionIndex(vector<int>& nums, int target, int left_right)
{
    int l = 0;
    int r = nums.size() - 1;
    
    int mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        
        if (nums[mid] > target)
        {
            r = mid - 1;
        }
        else if (nums[mid] < target)
        {
            l = mid + 1;
        }
        
        if (left_right == 1 && nums[mid] == target) {
            if (mid >= 1 && (nums[mid - 1] == target))
                r = mid - 1;
            else
                return mid;
        }
        
        if (left_right == 2 && nums[mid] == target) {
            if (mid <= (nums.size() - 2) && (nums[mid + 1] == target))
                l = mid + 1;
            else
                return mid;
        }
    }
    
    return l;
}

```


### 167. 两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

```

```
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) {
    *returnSize = 2;
    int head = 0, tail = numbersSize - 1;
    while (head < tail)
    {
        int tmp = numbers[head] + numbers[tail];
        
        if (tmp == target)
        {
            numbers[0] = head + 1;
            numbers[1] = tail + 1;
            return numbers;
        }
        
        if (tmp < target) head++;
        if (tmp > target) tail--;
    }
    
    return numbers;
}

```


### 15. 三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```

```
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    
    if (nums.size() < 1) return res;
    std::sort(nums.begin(), nums.end());
    
    for (int i = 0; i < nums.size() - 1; i++)
    {            
        if (i == 0 || (i > 0 && nums[i] != nums[i - 1]))
        {
            int l = i + 1, r = nums.size() - 1, sum = 0 - nums[i];
            
            while(l < r)
            {
                if (sum == (nums[l] + nums[r]))
                {
                    vector<int> tmp = {nums[i], nums[l], nums[r]};
                    res.push_back(tmp);
                    
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    
                    l++;r--;
                }
                else if (sum < (nums[l] + nums[r]))
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
    }
    
    return res;
}
```


关键点

> 本题需要注意的是数组中会存在重复的数，这些重复的数绝对不能在 i、i+1、l、l+1、r、r+1 出现。

### 16. 最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
int threeSumClosest(vector<int>& nums, int target) {
    if (nums.size() < 1) return 0;
    std::sort(nums.begin(), nums.end());
    int res = INT_MAX / 2;
    
    for (int i = 0; i < nums.size() - 1; i++)
    {
        int l = i + 1, r = nums.size() - 1;
        
        while (l < r)
        {
            int sum = nums[i] + nums[r] + nums[l];
            if (abs(target - sum) < abs(target - res)) res = sum;
            
            if (sum > target)
            {
                r--;
            }
            else {
                l++;
            }
        }
    }
    
    return res;
}

```

### 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```

核心代码

```
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    if (nums.size() < 1) return res;
    std::sort(nums.begin(), nums.end());
    int n = nums.size();
    
    for (int i = 0; i < nums.size() - 3; i++)
    {
        if(i > 0 && nums[i] == nums[i-1]) continue;
        if ((nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3]) > target) break;
        if ((nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3]) < target) continue;
        
        for (int j = i + 1; j < nums.size() - 2; j++)
        {
            if(j > i + 1 && nums[j] == nums[j-1]) continue;
            if ((nums[i] + nums[j] + nums[j + 1] + nums[j + 2]) > target) break;
            if ((nums[i] + nums[j] + nums[n - 1] + nums[n - 2]) < target) continue;
            
            int l = j + 1, r = nums.size() - 1;
            while (l < r)
            {
                int sum = nums[i] + nums[j] + nums[l] + nums[r];
                if ((sum) == target)
                {
                    vector<int> tmp = {nums[i], nums[j], nums[l], nums[r]};
                    res.push_back(tmp);
                    
                    while (l < r && nums[l] == nums[l + 1]) {l++;}
                    while (l < r && nums[r] == nums[r - 1]) {r--;}
                    
                    l++;r--;
                }
                else if (sum > target)
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
    }
    
    return res;
}

```

关键点

> if(i > 0 && nums[i] == nums[i-1]) continue; 是特别重要的判断

### 209. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。

```

```
int minSubArrayLen(int s, vector<int>& nums) {
    if (s == 0 || nums.size() < 1) return 0;
    
    int n = nums.size();
    vector<int> sum(n + 1, 0);
    sum[0] = 0;
    for (int i = 1; i <= n; i++)
    {
        sum[i] = sum[i - 1] + nums[i - 1];
    }
    
    int res = INT_MAX / 2;
    for (int i = 1; i <= n; i++)
    {
        int toFind = s + sum[i - 1];
        
        auto index = std::lower_bound(sum.begin(), sum.end(), toFind);
        if (index != sum.end())
        {
            res = std::min(res, static_cast<int>(index - sum.begin() - i + 1));
        }
    }
    
    return (res == INT_MAX / 2) ? 0 : res;
}

```


### 33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。


```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

```

核心代码

```
int search(vector<int>& nums, int target) {
    if (nums.size() < 1) return -1;
    
    int l = 0, r = nums.size() - 1, mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] == target) return mid;
        
        if (nums[l] <= nums[mid])
        {
            if (target >= nums[l] && target < nums[mid])
            {
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        else
        {
            if (target > nums[mid] && target <= nums[r])
            {
                l = mid + 1;
            }
            else
            {
                r = mid - 1;
            }
        }
    }
    
    return nums[l] == target ? l : -1;
}

```

### 81. 搜索旋转排序数组 II

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true

```

核心代码

```
bool search(vector<int>& nums, int target) {
    if (nums.size() < 1) return false;
    
    int l = 0, r = nums.size() - 1, mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] == target) return true;
        
        if (nums[l] < nums[mid])
        {
            if (target >= nums[l] && target < nums[mid])
            {
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        else if (nums[l] > nums[mid])
        {
            if (target > nums[mid] && target <= nums[r])
            {
                l = mid + 1;
            }
            else
            {
                r = mid - 1;
            }
        }
        else
        {
            l++;
        }
    }
    
    return nums[l] == target ? true : false;
}

```

### 153. 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

```
输入: [3,4,5,1,2]
输出: 1

```

```
int findMin(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        if (nums[l] < nums[r]) return nums[l];
        
        int mid = (l + r) / 2;
        if (mid >= 1 && nums[mid - 1] > nums[mid]) return nums[mid];
        
        if (nums[mid] >= nums[0])
        {
            l = mid + 1;
        }
        else
        {
            r = mid;
        }
    }
    
    return nums[l];
}

```

关键点

> 注意一个升序而且并没有被旋转的数组也被认为是测试样例，因此 if (nums[l] < nums[r]) return nums[l]; 不能少。

### 154. 寻找旋转排序数组中的最小值 II

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

```
输入: [2,2,2,0,1]
输出: 0

```

```
int findMin(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        if (nums[l] < nums[r]) return nums[l];
        
        int mid = (l + r) / 2;
        
        if (nums[mid] > nums[0])
        {
            l = mid + 1;
        }
        else if (nums[mid] < nums[0])
        {
            r = mid;
        }
        else
        {
            l++;
        }
    }
    
    return nums[l];
}

```

### 162. 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。

```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。

```

```
int findPeakElement(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        int mid = (l + r) / 2;
        
        if (nums[mid] > nums[mid + 1])
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    
    return l;
}

```

### 74. 搜索二维矩阵

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。


```
输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

```

```
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.size() < 1) return false;
    if (matrix[0].size() < 1) return false;
    
    int m = matrix.size();
    int n = matrix[0].size();
    int l = 0, r = m * n - 1;
    
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (matrix[mid / n][mid % n] == target)
        {
            return true;
        }
        else if (matrix[mid / n][mid % n] > target)
        {
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    
    return matrix[l / n][l % n] == target;
}

```

### 29. 两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

```
输入: dividend = 7, divisor = -3
输出: -2

```

```
int divide(int dividend, int divisor) {
    if(divisor == 1)
        return dividend;
    
    if(dividend == INT_MIN && divisor == INT_MIN)
        return 1;
    
    if(dividend == INT_MIN && abs(divisor) == 1)
        return INT_MAX;
    
    
    
    long long res = 0;
    long long n = abs((long long) dividend);
    long long d = abs((long long) divisor);
    
    while (n >= d)
    {
        long long tmp = d;
        long long time = 1;
        
        while ((tmp << 1) < n) {tmp <<= 1; time <<= 1; }
        
        n -= tmp;
        res += time;
    }
    
    if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))
        return -res;
    
    return res;
}

```

### 50. Pow(x, n)

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

```
double myPow(double x, int n) {
    double res = 1;
    long absN = abs((long) n);
    
    while (absN > 0)
    {
        if ((absN & 1) == 1)
        {
            res *= x;
            absN -= 1;
        }
        else
        {
            x *= x;
            absN >>= 1;
        }
    }
    
    return n > 0 ? res : 1 / res;
}

```

### 69. x 的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

```

```
int mySqrt(int x) {
    if (x == 0) return 0;
    
    int l = 1, r = x;
    
    while (1)
    {
        int mid = l + (r - l) / 2;
        
        if (mid == (x / mid))
            return mid;
        
        if (mid > (x / mid))
        {
            r = mid - 1;
        }
        else 
        {
            if ((mid + 1) > x / (mid + 1))
                return mid;
            
            l = mid + 1;
        }
    }
    
    return l;
}

```

### 278. 第一个错误的版本

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 

```

```
int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}

```

## 快慢指针

### 27. 移除元素

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。

```

核心代码

```
int removeElement(int* nums, int numsSize, int val) {
    if (numsSize < 1) return 0;
    
    int head = 0, tail = numsSize - 1;
    while (head < tail)
    {
        while (head < tail && nums[head] != val) head++;
        while (head < tail && nums[tail] == val) tail--;
        
        if (head < tail)
        {
            int tmp = nums[head];
            nums[head] = nums[tail];
            nums[tail] = tmp;
            head++;
            tail--;
        }
        
        
    }
    
    if (nums[0] == val) return 0;
    
    return (nums[head] == val) ? head : (head + 1);
}

```

### 26. 删除排序数组中的重复项

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

```

核心代码

```
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 1) return numsSize;
    int slow = 0, fast = 0;
    
    while (fast < numsSize)
    {
        if (nums[fast] != nums[slow])
        {
            nums[++slow] = nums[fast];
        }
        
        fast++;
    }
    
    return (slow + 1);
}

```

### 80. 删除排序数组中的重复项 II

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。

```

```
int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();
    
    int ret = 2;
    for (int i = 2; i < nums.size(); i++)
    {
        if (nums[i] > nums[ret - 2])
        {
            nums[ret] = nums[i];
            ret++;
        }
    }
    
    return ret;
}

```

### 75. 颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

```

进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

```
void sortColors(vector<int>& nums) {
    if (nums.size() < 1) return;
    
    int l = 0, r = nums.size() - 1, count = 0;
    int i = 0;
    while (i < nums.size())
    {
        if (nums[i] == 0)
        {
            nums[i] = nums[l];
            nums[l] = 0;
            l++;
        }
        
        if (nums[i] == 2 && i < r)
        {
            nums[i] = nums[r];
            nums[r] = 2;
            r--;
            continue;
        }
        
        i++;
    }
}

```

### 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

```
输入: [3,1,3,4,2]
输出: 3

```

```
int findDuplicate(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int slow = nums[0];
    int fast = nums[nums[0]];
    
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    
    fast = 0;
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return fast;
}

```

### 283. 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

```

```
void moveZeroes(int* nums, int numsSize) {
    int current = 0;
    
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] == 0)
            continue;
        
        nums[current++] = nums[i];
    }
    
    for (int i = current; i < numsSize; i++)
        nums[i] = 0;
}

```


## 交换排序

### 442. 数组中重复的数据

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]

```

```
vector<int> findDuplicates(vector<int>& nums) {
    int numsSize = nums.size();
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != nums[nums[i] - 1])
        {
            int index = nums[i] - 1;

            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }

    vector<int> ret;
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            ret.push_back(nums[i]);
        }
    }

    return ret;
}

```

### 448. 找到所有数组中消失的数字

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

```


```
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {
    int *ret = (int *) malloc(numsSize * sizeof(int));
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != (i + 1))
        {
            int index = nums[i] - 1;
            
            if (nums[i] == nums[index])
                break;
            
            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }
    
    *returnSize = 0;
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            ret[(*returnSize)] = i + 1;
            (*returnSize)++;
        }
    }
    
    return ret;
}

```

### 41. 缺失的第一个正数

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

```
输入: [1,2,0]
输出: 3

```

```
int firstMissingPositive(vector<int>& nums) {
    if (nums.size() < 1) return 1;
    
    for (int i = 0; i < nums.size(); i++)
    {
        while (nums[i] > 0 && nums[i] <= nums.size() && nums[i] != nums[nums[i] - 1])
        {
            int tmp = nums[i];
            nums[i] = nums[tmp - 1];
            nums[tmp - 1] = tmp;
        }
    }
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] != (i + 1))
            return (i + 1);
    }
    
    return nums.size() + 1;
}

```

### 268. 缺失数字

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8

```

```
int missingNumber(int* nums, int numsSize) {
    int sum = numsSize * (numsSize + 1) / 2;
    
    int rsum = 0;
    for (int i = 0; i < numsSize; i++)
        rsum += nums[i];
    
    return (sum - rsum);
}

```


## 其他

### 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

核心代码

```
void nextPermutation(vector<int>& nums) {
    if (nums.size() <= 1) return;
    
    int i = nums.size() - 1;
    while (i >= 1 && nums[i - 1] >= nums[i])
        i--;
    
    if (i >= 1)
    {
        i--;
        
        int j = nums.size() - 1;
        while (j >= 0 && nums[i] >= nums[j])
            j--;
        
        swap(nums, i, j);
        
        i++;
    }
    
    std::reverse(nums.begin() + i, nums.end());
}
    
void swap(vector<int>& nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

```

关键点

> 本题的思路是先找出降序排列的子串：i-(size-1),因为这部分子串已经是最高级别的排列方式，下一步该子串应该扩大范围到 i-1 位置。
> 
> 这个时候，就要从 (i-1)-(size-1) 范围中选取一个较大的值，不一定是最大值，然后放到 i-1 位置，对 i 位置以后子串进行升序排列。

### 66. 加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。

```

```
int* plusOne(int* digits, int digitsSize, int* returnSize) {
    *returnSize = digitsSize;

    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (digits[i] == 9)
        {
            digits[i] = 0;
            
            if (i == 0) {
                *returnSize = digitsSize + 1;
                int *returnArray = (int *) malloc((digitsSize + 1) * sizeof(int));
                memset(returnArray, 0 , (digitsSize + 1) * sizeof(int));
                returnArray[0] = 1;
                
                return returnArray;
            }
            else 
            {
              continue;  
            }
        }
           
        digits[i]++;
        return digits;
    }
    
    return digits;
}

```

### 169. 求众数

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

```
输入: [2,2,1,1,1,2,2]
输出: 2

```

```
int majorityElement(int* nums, int numsSize) {
    int element = INT_MIN;int count = 0;
    
    for (int i = 0; i < numsSize; i++)
    {
        if (count == 0)
        {
            element = nums[i];
            count++;
        } 
        else if (element == nums[i])
        {
            count++;
        } 
        else
        {
            count--;
        }
        
        if (count > numsSize / 2)
            return element;
    }
    
    return element;
}

```

### 229. 求众数 II

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

```
输入: [1,1,1,3,3,2,2,2]
输出: [1,2]

```

```
vector<int> majorityElement(vector<int>& nums) {
    vector<int> res;
    if (nums.size() < 1) return res;
    
    int canA = nums[0];
    int canB = nums[0];
    int countA = 0;
    int countB = 0;
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] == canA)
        {
            countA++;
            continue;
        }
        
        if (nums[i] == canB)
        {
            countB++;
            continue;
        }
        
        if (countA == 0)
        {
            canA = nums[i];
            countA++;
            continue;
        }
        
        if (countB == 0)
        {
            canB = nums[i];
            countB++;
            continue;
        }
        
        countA--;
        countB--;
    }
    
    countA = 0;
    countB = 0;
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] == canA)
        {
            countA++;
            continue;
        }
        
        if (nums[i] == canB)
        {
            countB++;
            continue;
        }
    }
    
    if (countA > nums.size() / 3)
        res.push_back(canA);	
    
    if (countB > nums.size() / 3)
        res.push_back(canB);
    
    return res;
}

```

### 189. 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

```

```
void rotate(vector<int>& nums, int k) {
    if (nums.size() < 2) { return; }
    k %= nums.size();
    
    rever(nums, 0, nums.size());
    rever(nums, 0, k);
    rever(nums, k, nums.size());
}
    
void rever(vector<int>& nums, int begin, int size)
{
    int i = begin; 
    int j = size - 1;
    
    while (i < j)
    {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        
        i++;j--;
    }
}

```

### 219. 存在重复元素 II

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false

```

```
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    map<int, int> myMap;
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (myMap.find(nums[i]) == myMap.end())
        {
            myMap[nums[i]] = i;
        }
        else 
        {
            if ((i - myMap[nums[i]]) > k)
            {
                myMap[nums[i]] = i;
            }
            else
            {
                return true;
            }
        }
    }
    
    return false;
}

```

### 128. 最长连续序列

给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 O(n)。

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

```

```
int longestConsecutive(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    set<int> numSet;
    for (int i = 0; i < nums.size(); i++)
    {
        numSet.insert(nums[i]);
    }
    
    int res = 0;
    for (int i = 0; i < nums.size(); i++)
    {
        if (! numSet.count(nums[i] - 1))
        {
            int cur = nums[i];
            int curlen = 1;
            
            while (numSet.count(cur + 1))
            {
                cur += 1;
                curlen += 1;
            }
            
            res = std::max(res, curlen);
        }
    }
    
    return res;
}

```

### 228. 汇总区间

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

```
输入: [0,2,3,4,6,8,9]
输出: ["0","2->4","6","8->9"]
解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。

```

```
vector<string> summaryRanges(vector<int>& nums) {
    vector<string> res;
    if (nums.size() < 1) return res;
    
    for (int i = 0; i < nums.size(); i++)
    {
        int start = i;
        int cur = nums[i];
        
        while (((i + 1) < nums.size()) && (nums[i + 1] == (cur + 1)))
        {
            cur += 1;
            i++;
        }
        
        string tmp;
        if (start == i)
        {
            tmp = std::to_string(nums[i]);
        }
        else
        {
            tmp = std::to_string(nums[start]);
            tmp += "->";
            tmp += std::to_string(nums[i]);
        }
        
        res.push_back(tmp);
    }
    
    return res;
}

```

### 238. 除自身以外数组的乘积

给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

```
输入: [1,2,3,4]
输出: [24,12,8,6]

```

```
vector<int> productExceptSelf(vector<int>& nums) {
    if (nums.size() < 1) return nums;
    
    vector<int> ret(nums.size());
    int pre = 1;
    for (int i = nums.size() - 1; i >= 0; i--)
    {
        ret[i] = pre;
        pre *= nums[i];
    }
    
    pre = 1;
    for (int i = 0; i < nums.size(); i++)
    {
        ret[i] = ret[i] * pre;
        pre *= nums[i];
    }
    
    return ret;
}

```

## 矩阵

### 48. 旋转图像

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


```

```
/*
 * clockwise rotate
 * first reverse up to down, then swap the symmetry 
 * 1 2 3     7 8 9     7 4 1
 * 4 5 6  => 4 5 6  => 8 5 2
 * 7 8 9     1 2 3     9 6 3
*/
void rotate(vector<vector<int> > &matrix) {
    reverse(matrix.begin(), matrix.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}

/*
 * anticlockwise rotate
 * first reverse left to right, then swap the symmetry
 * 1 2 3     3 2 1     3 6 9
 * 4 5 6  => 6 5 4  => 2 5 8
 * 7 8 9     9 8 7     1 4 7
*/
void anti_rotate(vector<vector<int> > &matrix) {
    for (auto vi : matrix) reverse(vi.begin(), vi.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}

```

### 54. 螺旋矩阵

给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]

```

```
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> res;
    if (matrix.size() < 1) return res;
    
    int r1 = 0, r2 = matrix.size() - 1;
    int c1 = 0, c2 = matrix[0].size() - 1;
    
    while (r1 <= r2 && c1 <= c2)
    {
        for (int c = c1; c <= c2; c++) res.push_back(matrix[r1][c]);
        for (int r = r1 + 1; r <= r2; r++) res.push_back(matrix[r][c2]);
        
        if (r1 < r2 && c1 < c2)
        {
            for (int c = c2 - 1; c >= c1; c--) res.push_back(matrix[r2][c]);
            for (int r = r2 - 1; r > r1; r--) res.push_back(matrix[r][c1]);
        }
        
        r1++;
        r2--;
        c1++;
        c2--;
    }
    
    return res;
}

```


### 59. 螺旋矩阵 II

给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```

```
vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> res(n, vector<int>(n, 0));
    
    int r1 = 0, r2 = n - 1;
    int c1 = 0, c2 = n - 1;
    int i = 1;
    while (r1 <= r2 && c1 <= c2)
    {
        for (int c = c1; c <= c2; c++) res[r1][c] = i++;
        for (int r = r1 + 1; r <= r2; r++) res[r][c2] = i++;
        
        if (r1 < r2 && c1 < c2)
        {
            for (int c = c2 - 1; c >= c1; c--) res[r2][c] = i++;
            for (int r = r2 - 1; r > r1; r--) res[r][c1] = i++;
        }
        
        r1++;
        r2--;
        c1++;
        c2--;
    }
    
    return res;
}

```

### 73. 矩阵置零


给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

```
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

```

```
void setZeroes(vector<vector<int>>& matrix) {
    if (matrix.size() < 1) return;
    
    int m = matrix.size();
    int n = matrix[0].size();
    bool isRow = 0, isCol = 0;
    for (int j = 0; j < n; j++)
    {
        if (matrix[0][j] == 0)
            isRow = 1;
    }
    for (int j = 0; j < m; j++)
    {
        if (matrix[j][0] == 0)
            isCol = 1;
    }
    
    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            if (matrix[i][j] == 0)
            {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    
    for (int i = 1; i < m; i++)
    {
        if (matrix[i][0] == 0)
        {
            for (int j = 1; j < n; j++)
                matrix[i][j] = 0;
        }
    }
    
    for (int i = 1; i < n; i++)
    {
        if (matrix[0][i] == 0)
        {
            for (int j = 1; j < m; j++)
                matrix[j][i] = 0;
        }
    }
    
    if (isRow)
    {
        for (int j = 0; j < n; j++)
            matrix[0][j] = 0;
    }
    if (isCol)
    {
        for (int j = 0; j < m; j++)
            matrix[j][0] = 0;
    }
}

```

### 118. 杨辉三角

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

```
for (int i = 0; i < numRows; i++)
{
    for (int j = 0; j < i + 1; j++)
    {
        if (j == 0 || j == i) 
        {
           returnArray[i][j] = 1;
            continue;
        }
            
        returnArray[i][j] = returnArray[i - 1][j - 1] + returnArray[i - 1][j];
    }
}

```








## 附录题型总结：数组重复项

### 排序数组

#### 26. 删除排序数组中的重复项

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

```

核心代码

```
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 1) return numsSize;
    int slow = 0, fast = 0;
    
    while (fast < numsSize)
    {
        if (nums[fast] != nums[slow])
        {
            nums[++slow] = nums[fast];
        }
        
        fast++;
    }
    
    return (slow + 1);
}

```

#### 80. 删除排序数组中的重复项 II

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。

```

```
int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();
    
    int ret = 2;
    for (int i = 2; i < nums.size(); i++)
    {
        if (nums[i] > nums[ret - 2])
        {
            nums[ret] = nums[i];
            ret++;
        }
    }
    
    return ret;
}

```

### 数组无序空间复杂度不限

#### 219. 存在重复元素 II

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false

```

```
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    map<int, int> myMap;
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (myMap.find(nums[i]) == myMap.end())
        {
            myMap[nums[i]] = i;
        }
        else 
        {
            if ((i - myMap[nums[i]]) > k)
            {
                myMap[nums[i]] = i;
            }
            else
            {
                return true;
            }
        }
    }
    
    return false;
}

```
### 数组无序限制空间复杂度

### 442. 数组中重复的数据

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]

```

```
vector<int> findDuplicates(vector<int>& nums) {
    int numsSize = nums.size();
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != nums[nums[i] - 1])
        {
            int index = nums[i] - 1;

            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }

    vector<int> ret;
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            ret.push_back(nums[i]);
        }
    }

    return ret;
}

```


#### 41. 缺失的第一个正数

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

```
输入: [1,2,0]
输出: 3

```

```
int firstMissingPositive(vector<int>& nums) {
    if (nums.size() < 1) return 1;
    
    for (int i = 0; i < nums.size(); i++)
    {
        while (nums[i] > 0 && nums[i] <= nums.size() && nums[i] != nums[nums[i] - 1])
        {
            int tmp = nums[i];
            nums[i] = nums[tmp - 1];
            nums[tmp - 1] = tmp;
        }
    }
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] != (i + 1))
            return (i + 1);
    }
    
    return nums.size() + 1;
}

```

### 数组无序限制空间复杂度限制改动数组

#### 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

```
输入: [3,1,3,4,2]
输出: 3

```

```
int findDuplicate(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int slow = nums[0];
    int fast = nums[nums[0]];
    
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    
    fast = 0;
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return fast;
}

```

### 特例题型

#### 268. 缺失数字

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8

```

```
int missingNumber(int* nums, int numsSize) {
    int sum = numsSize * (numsSize + 1) / 2;
    
    int rsum = 0;
    for (int i = 0; i < numsSize; i++)
        rsum += nums[i];
    
    return (sum - rsum);
}

```

### 136. 只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

```
输入: [4,1,2,1,2]
输出: 4

```

```
int singleNumber(vector<int>& nums) {
    int a = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        a ^= nums[i];
    }
    
    return a;
}

```

### 137. 只出现一次的数字 II

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

```
int singleNumber(vector<int>& nums) {
    std::set<int> s;
    long long sum = 0;
    long long sum1 = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        sum1 += nums[i];
        
        if (s.find(nums[i]) == s.end()) {
            sum += nums[i];
            s.insert(nums[i]);
        }
    }
    
    return (sum * 3 - sum1) / 2;
}

```

复杂的解法：

```
使用一个32维的数组，用这个32维的数组存储所有数里面第0位1的总数，第1位1的总数。。。第31位1的总数。

假如第0位1的个数是k的倍数，那么要求的这个数在该位一定是0，若不是k的倍数，那么要求的这个数在该位一定是1，第1位的1一直到第31位的1的个数同理。

int singleNumber(int A[], int n) {
    int count[32] = {0};
    int result = 0;
    for (int i = 0; i < 32; i++) {
        for (int j = 0; j < n; j++) {
            if ((A[j] >> i) & 1) {
                count[i]++;
            }
        }
        result |= ((count[i] % 3) << i);
    }
    return result;
}


public int singleNumber(int[] nums) {
    int one = 0, two = 0, three;
    for (int num : nums) {
        // two的相应的位等于1，表示该位出现2次
        two |= (one & num);
        // one的相应的位等于1，表示该位出现1次
        one ^= num;
        // three的相应的位等于1，表示该位出现3次
        three = (one & two);
        // 如果相应的位出现3次，则该位重置为0
        two &= ~three;
        one &= ~three;
    }
    return one;
}

```

### 7. 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

```
int reverse(int x) {
    int flag = 1;
    if (x < 0) flag = -1;
    x = abs(x);
    
    vector<int> v;
    while (x > 0) {
        v.push_back(x % 10);
        
        x = x / 10;
    }
    
    int result = 0;
    for (int i = 0; i < v.size(); i++) {
        result = result * 10 + v[i];
    }
    
    return result;
}

```

### 9. 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
输入: -121
输出: false

```

```
bool isPalindrome(int x) {
    if (x < 0) return 0;
    
    vector<int> v;
    while (x > 0) {
        v.push_back(x % 10);
        
        x = x / 10;
    }
    
    int l = 0, r = v.size() - 1;
    while (l < r) {
        if (v[l] != v[r]) return 0;
        
        l++;r--;
    }
    
    return true;
}

```

### 134. 加油站

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

```

```
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int len = gas.size();
    for (int index = 0; index < len; index++) {        
        int r = 0;
        bool success = 1;
        for (int i = 0; i < len; i++) {
            int cur = (index + i) % len;
            r += gas[cur] - cost[cur];
            
            if (r < 0) {success = 0; break;};
        }
        
        if (success) return index;
    }
    
    return -1;
}

```

### 135. 分发糖果

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

```
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。

```

```
int candy(vector<int>& ratings) {
    int sum = 0;
    vector<int> l(ratings.size(), 1);
    vector<int> r(ratings.size(), 1);
    
    l[0] = 1;
    for (int i = 1; i < ratings.size(); i++) {
        if (ratings[i] > ratings[i - 1]) l[i] = l[i - 1] + 1;
        else l[i] = 1;
    }
    
    r[ratings.size() - 1] = 1;
    for (int i = ratings.size() - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) r[i] = r[i + 1] + 1;
    }
    
    for (int i = 0; i < ratings.size(); i++) {
        sum += std::max(l[i], r[i]);
    }
    
    return sum;
}

```

### 220. 存在重复元素 III

给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。

```
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    if (k >= 10000) return false;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j <= i + k; j++) {
            if (j >= nums.size()) break;
            
            if (abs((long)nums[j] - (long)nums[i]) <= t) return true;
        }
    }
    
    return false;
}

```




