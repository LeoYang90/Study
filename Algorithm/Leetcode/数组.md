# 数组

## 合并数组

### 4. 寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0

```

核心代码

```
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int size1 = nums1.size();
    int size2 = nums2.size();
    int sum = size1 + size2;
    
    int mid = 0;
    if (sum % 2 == 1) mid = (sum + 1) / 2;
    if (sum % 2 == 0) mid = sum / 2;
    
    int index = 0, index1 = 0, index2 = 0;
    double res = 0;
    while (index1 < size1 && index2 < size2)
    { 
        int tmp = 0;
        if (nums1[index1] <= nums2[index2])
        {
            tmp = nums1[index1];
            index1++;
        }
        else
        {
            tmp = nums2[index2];
            index2++;
        }
        
        if (index == (mid - 1)) {
            res += tmp;
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += tmp; res /= 2; return res;}
        
        index++;
    }
    
    while (index1 < size1)
    {
        if (index == (mid - 1)) {
            res += nums1[index1];
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += nums1[index1]; res /= 2; return res;}
        
        index1++;
        index++;
    }
    
    while (index2 < size2)
    {
        if (index == (mid - 1)) {
            res += nums2[index2];
            
            if (sum % 2 == 1)
                return res;
        }
        
        if (index == (mid)) {res += nums2[index2]; res /= 2; return res;}
        
        index2++;
        index++;
    }
    
    return res;
}

```

关键点

> 本题需要注意的是中位数的位置是 (sum + 1)/2
> 
> 当偶数个数的时候，中位数位置是 mid-1,mid

### 56. 合并区间

给出一个区间的集合，请合并所有重叠的区间。

```
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

```

```
vector<Interval> merge(vector<Interval>& intervals) {
    if (intervals.size() <= 1) return intervals;
    
    std::sort(intervals.begin(), intervals.end(), [](Interval a, Interval b) {
        return a.start < b.start;
    });
    
    vector<Interval> tmp = {intervals[0]};
    for (int i = 1; i < intervals.size(); i++)
    {
        Interval pre = tmp[tmp.size() - 1];
        Interval cur = intervals[i];
        
        if (pre.end >= cur.start && pre.end <= cur.end)
        {
            tmp[tmp.size() - 1].end = cur.end;
        }
        else if (pre.end < cur.start)
        {
            tmp.push_back(cur);
        }
    }
    
    return tmp;
}

```

关键点

> 排序之后，只需要关心前一个元素的 end 坐标在后一个元素的 start~end 范围关系
> 
> 如果在 start 之前，直接压入队列
> 
> 如果在 start~end 之间，修改前一个元素的 end 坐标
> 
> 如果在 end 之后，略过该元素。

### 57. 插入区间

给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）.

```
输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
输出: [[1,5],[6,9]]

```
	

```
vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
    vector<Interval> res = {newInterval};
    if (intervals.size() < 1) return res;
    
    vector<Interval> preSe;
    vector<Interval> postSe;
    for (int i = 0; i < intervals.size(); i++)
    {
        Interval cur = intervals[i];
        
        if (cur.end < newInterval.start)
        {
            preSe.push_back(cur);
        }
        else if (cur.start > newInterval.end)
        {
            postSe.push_back(cur);
        }
        else
        {
            if (cur.start < newInterval.start)
                newInterval.start = cur.start;
            
            if (cur.end > newInterval.end)
                newInterval.end = cur.end;
        }
    }
    
    res = preSe;
    res.push_back(newInterval);
    for (int i = 0; i < postSe.size(); i++)
        res.push_back(postSe[i]);
    
    return res;
}

```

关键点

> 重心在 newInterval 的范围
> 
> 当前元素如果不在 newInterval 的范围内，那么直接压入队列
> 
> newInterval 的 start 坐标在 cur 元素范围内，修改 newInterval 的 start
> 
> 类似地，newInterval 的 end 坐标在 cur 元素范围内，修改 newInterval 的 end

### 66. 加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。

```

```
int* plusOne(int* digits, int digitsSize, int* returnSize) {
    *returnSize = digitsSize;

    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (digits[i] == 9)
        {
            digits[i] = 0;
            
            if (i == 0) {
                *returnSize = digitsSize + 1;
                int *returnArray = (int *) malloc((digitsSize + 1) * sizeof(int));
                memset(returnArray, 0 , (digitsSize + 1) * sizeof(int));
                returnArray[0] = 1;
                
                return returnArray;
            }
            else 
            {
              continue;  
            }
        }
           
        digits[i]++;
        return digits;
    }
    
    return digits;
}

```

## 数组变幻

### 189. 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

```

```
void rotate(vector<int>& nums, int k) {
    if (nums.size() < 2) { return; }
    k %= nums.size();
    
    rever(nums, 0, nums.size());
    rever(nums, 0, k);
    rever(nums, k, nums.size());
}
    
void rever(vector<int>& nums, int begin, int size)
{
    int i = begin; 
    int j = size - 1;
    
    while (i < j)
    {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        
        i++;j--;
    }
}

```

### 27. 移除元素

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。

```

核心代码

```
int removeElement(int* nums, int numsSize, int val) {
    if (numsSize < 1) return 0;
    
    int head = 0, tail = numsSize - 1;
    while (head < tail)
    {
        while (head < tail && nums[head] != val) head++;
        while (head < tail && nums[tail] == val) tail--;
        
        if (head < tail)
        {
            int tmp = nums[head];
            nums[head] = nums[tail];
            nums[tail] = tmp;
            head++;
            tail--;
        }
        
        
    }
    
    if (nums[0] == val) return 0;
    
    return (nums[head] == val) ? head : (head + 1);
}

```

### 调整数组顺序使奇数位于偶数前面

```
void ReorderOddEven_1(int *pData, unsigned int length)
{
    if(pData == nullptr || length == 0)
        return;

    int *pBegin = pData;
    int *pEnd = pData + length - 1;

    while(pBegin < pEnd)
    {
        // 向后移动pBegin，直到它指向偶数
        while(pBegin < pEnd && (*pBegin & 0x1) != 0)
            pBegin ++;

        // 向前移动pEnd，直到它指向奇数
        while(pBegin < pEnd && (*pEnd & 0x1) == 0)
            pEnd --;

        if(pBegin < pEnd)
        {
            int temp = *pBegin;
            *pBegin = *pEnd;
            *pEnd = temp;
        }
    }
}

```

### 26. 删除排序数组中的重复项

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

```

核心代码

```
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 1) return numsSize;
    int slow = 0, fast = 0;
    
    while (fast < numsSize)
    {
        if (nums[fast] != nums[slow])
        {
            nums[++slow] = nums[fast];
        }
        
        fast++;
    }
    
    return (slow + 1);
}

```

### 80. 删除排序数组中的重复项 II

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。

```

```
int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 2) return nums.size();
    
    int ret = 2;
    for (int i = 2; i < nums.size(); i++)
    {
        if (nums[i] > nums[ret - 2])
        {
            nums[ret] = nums[i];
            ret++;
        }
    }
    
    return ret;
}

```

### 75. 颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]

```

进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？

```
void sortColors(vector<int>& nums) {
    if (nums.size() < 1) return;
    
    int l = 0, r = nums.size() - 1, count = 0;
    int i = 0;
    while (i < nums.size())
    {
        if (nums[i] == 0)
        {
            nums[i] = nums[l];
            nums[l] = 0;
            l++;
        }
        
        if (nums[i] == 2 && i < r)
        {
            nums[i] = nums[r];
            nums[r] = 2;
            r--;
            continue;
        }
        
        i++;
    }
}

```


### 283. 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]

```

```
void moveZeroes(int* nums, int numsSize) {
    int current = 0;
    
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] == 0)
            continue;
        
        nums[current++] = nums[i];
    }
    
    for (int i = current; i < numsSize; i++)
        nums[i] = 0;
}

```


## 二分查找

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```
int searchInsert(int* nums, int numsSize, int target) {
    if (numsSize == 0) return 0;
    if (numsSize == 1 && nums[0] < target) return 1;
    
    int left = 0, right = numsSize - 1;
    
    int mid = 0;
    while (left <= right)
    {
        mid = (left + right) / 2;
        
        if (nums[mid] < target) left = mid + 1;
        if (nums[mid] > target) right = mid - 1;
        if (nums[mid] == target) return mid;
        
    }
    
    return left;
}

```

关键点

> 本题是标准的二分查找代码
> 
> 注意 left right 等初值的设定
> 
> 注意 while(l <= r) 的设定，一般来说，写成 l < r 也不会有大问题，无非返回的只能是 l， 而不能是 mid。
> 
> 录入 [1,3,5,6] 2，如果是 l < r,那么 l 没有任何机会自增，最后结果是 l=0, r=0;如果是 l <= r,那么最后结果是 l=1,r=0
> 
> 但是在本题中需要找出插入点，那么就需要等于。
> 
> 注意返回的是 left

### 34. 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。



```
vector<int> searchRange(vector<int>& nums, int target) {
    vector<int> res = {-1, -1};
    
    int leftindex = extremeInsertionIndex(nums, target, 1);
    
    if (leftindex == nums.size() || nums[leftindex] != target)
    {
        return res;
    }
    
    res[0] = leftindex;
    
    int rightindex = extremeInsertionIndex(nums, target, 2);
    res[1] = rightindex;
    
    return res;
}
    
int extremeInsertionIndex(vector<int>& nums, int target, int left_right)
{
    int l = 0;
    int r = nums.size() - 1;
    
    int mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        
        if (nums[mid] > target)
        {
            r = mid - 1;
        }
        else if (nums[mid] < target)
        {
            l = mid + 1;
        }
        
        if (left_right == 1 && nums[mid] == target) {
            if (mid >= 1 && (nums[mid - 1] == target))
                r = mid - 1;
            else
                return mid;
        }
        
        if (left_right == 2 && nums[mid] == target) {
            if (mid <= (nums.size() - 2) && (nums[mid + 1] == target))
                l = mid + 1;
            else
                return mid;
        }
    }
    
    return l;
}

```

### 11. 盛最多水的容器

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49

```

核心代码

```
int maxArea(vector<int>& height) {
    int res = 0;
    
    int l = 0, r = height.size() - 1;
    while (l < r)
    {
        res = std::max(res, std::min(height[l], height[r]) * (r - l));
        
        if (height[l] < height[r])
            l++;
        else
            r--;
    }
    
    return res;
}

```

### 167. 两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

```

```
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) {
    *returnSize = 2;
    int head = 0, tail = numbersSize - 1;
    while (head < tail)
    {
        int tmp = numbers[head] + numbers[tail];
        
        if (tmp == target)
        {
            numbers[0] = head + 1;
            numbers[1] = tail + 1;
            return numbers;
        }
        
        if (tmp < target) head++;
        if (tmp > target) tail--;
    }
    
    return numbers;
}

```

### 和为 S 的连续正数序列

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

```
void FindContinuousSequence(int sum)
{
    if(sum < 3)
        return;

    int small = 1; 
    int big = 2;
    int middle = (1 + sum) / 2;
    int curSum = small + big;

    while(small < middle)
    {
        if(curSum == sum)
            PrintContinuousSequence(small, big);

        while(curSum > sum && small < middle)
        {
            curSum -= small;
            small ++;

            if(curSum == sum)
                PrintContinuousSequence(small, big);
        }

        big ++;
        curSum += big;
    }
}

```

### 15. 三数之和

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

```

```
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    
    if (nums.size() < 1) return res;
    std::sort(nums.begin(), nums.end());
    
    for (int i = 0; i < nums.size() - 1; i++)
    {            
        if (i == 0 || (i > 0 && nums[i] != nums[i - 1]))
        {
            int l = i + 1, r = nums.size() - 1, sum = 0 - nums[i];
            
            while(l < r)
            {
                if (sum == (nums[l] + nums[r]))
                {
                    vector<int> tmp = {nums[i], nums[l], nums[r]};
                    res.push_back(tmp);
                    
                    while (l < r && nums[l] == nums[l + 1]) l++;
                    while (l < r && nums[r] == nums[r - 1]) r--;
                    
                    l++;r--;
                }
                else if (sum < (nums[l] + nums[r]))
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
    }
    
    return res;
}
```


关键点

> 本题需要注意的是数组中会存在重复的数，这些重复的数绝对不能在 i、i+1、l、l+1、r、r+1 出现。

### 16. 最接近的三数之和

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
int threeSumClosest(vector<int>& nums, int target) {
    if (nums.size() < 1) return 0;
    std::sort(nums.begin(), nums.end());
    int res = INT_MAX / 2;
    
    for (int i = 0; i < nums.size() - 1; i++)
    {
        int l = i + 1, r = nums.size() - 1;
        
        while (l < r)
        {
            int sum = nums[i] + nums[r] + nums[l];
            if (abs(target - sum) < abs(target - res)) res = sum;
            
            if (sum > target)
            {
                r--;
            }
            else {
                l++;
            }
        }
    }
    
    return res;
}

```

### 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]

```

核心代码

```
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    if (nums.size() < 1) return res;
    std::sort(nums.begin(), nums.end());
    int n = nums.size();
    
    for (int i = 0; i < nums.size() - 3; i++)
    {
        if(i > 0 && nums[i] == nums[i-1]) continue;
        if ((nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3]) > target) break;
        if ((nums[i] + nums[n - 1] + nums[n - 2] + nums[n - 3]) < target) continue;
        
        for (int j = i + 1; j < nums.size() - 2; j++)
        {
            if(j > i + 1 && nums[j] == nums[j-1]) continue;
            if ((nums[i] + nums[j] + nums[j + 1] + nums[j + 2]) > target) break;
            if ((nums[i] + nums[j] + nums[n - 1] + nums[n - 2]) < target) continue;
            
            int l = j + 1, r = nums.size() - 1;
            while (l < r)
            {
                int sum = nums[i] + nums[j] + nums[l] + nums[r];
                if ((sum) == target)
                {
                    vector<int> tmp = {nums[i], nums[j], nums[l], nums[r]};
                    res.push_back(tmp);
                    
                    while (l < r && nums[l] == nums[l + 1]) {l++;}
                    while (l < r && nums[r] == nums[r - 1]) {r--;}
                    
                    l++;r--;
                }
                else if (sum > target)
                {
                    r--;
                }
                else
                {
                    l++;
                }
            }
        }
    }
    
    return res;
}

```

关键点

> if(i > 0 && nums[i] == nums[i-1]) continue; 是特别重要的判断


### 33. 搜索旋转排序数组

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。


```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

```

核心代码

```
int search(vector<int>& nums, int target) {
    if (nums.size() < 1) return -1;
    
    int l = 0, r = nums.size() - 1, mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] == target) return mid;
        
        if (nums[l] <= nums[mid])
        {
            if (target >= nums[l] && target < nums[mid])
            {
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        else
        {
            if (target > nums[mid] && target <= nums[r])
            {
                l = mid + 1;
            }
            else
            {
                r = mid - 1;
            }
        }
    }
    
    return nums[l] == target ? l : -1;
}

```

注意点：

- 常规的二分法是比较 nums[mid] 的值和 target 的值，但是本题却是用 nums[l]、nums[r] 来比较，这个是最大的不同
- 注意比较时的等于条件。

### 81. 搜索旋转排序数组 II

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true

```

核心代码

```
bool search(vector<int>& nums, int target) {
    if (nums.size() < 1) return false;
    
    int l = 0, r = nums.size() - 1, mid = 0;
    while (l < r)
    {
        mid = (l + r) / 2;
        if (nums[mid] == target) return true;
        
        if (nums[l] < nums[mid])
        {
            if (target >= nums[l] && target < nums[mid])
            {
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        else if (nums[l] > nums[mid])
        {
            if (target > nums[mid] && target <= nums[r])
            {
                l = mid + 1;
            }
            else
            {
                r = mid - 1;
            }
        }
        else
        {
            l++;
        }
    }
    
    return nums[l] == target ? true : false;
}

```

### 153. 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

```
输入: [3,4,5,1,2]
输出: 1

```

```
int findMin(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        if (nums[l] < nums[r]) return nums[l];
        
        int mid = (l + r) / 2;
        //if (mid >= 1 && nums[mid - 1] > nums[mid]) return nums[mid];
        
        if (nums[mid] >= nums[0])
        {
            l = mid + 1;
        }
        else
        {
            r = mid;
        }
    }
    
    return nums[l];
}

```

关键点

> 注意一个升序而且并没有被旋转的数组也被认为是测试样例，因此 if (nums[l] < nums[r]) return nums[l]; 不能少。

### 154. 寻找旋转排序数组中的最小值 II

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

```
输入: [2,2,2,0,1]
输出: 0

```

```
int findMin(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        if (nums[l] < nums[r]) return nums[l];
        
        int mid = (l + r) / 2;
        
        if (nums[mid] > nums[0])
        {
            l = mid + 1;
        }
        else if (nums[mid] < nums[0])
        {
            r = mid;
        }
        else
        {
            l++;
        }
    }
    
    return nums[l];
}

```

### 162. 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。

```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。

```

```
int findPeakElement(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        int mid = (l + r) / 2;
        
        if (nums[mid] > nums[mid + 1])
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    
    return l;
}

```

### 数组中数值和下标相等的元素

假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组{-3, -1,1, 3, 5}中，数字3和它的下标相等。

```
int GetNumberSameAsIndex(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left <= right)
    {
        int middle = left + ((right - left) >> 1);
        if(numbers[middle] == middle)
            return middle;

        if(numbers[middle] > middle)
            right = middle - 1;
        else
            left = middle + 1;
    }

    return -1;
}
```

### 74. 搜索二维矩阵

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。


```
输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

```

```
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.size() < 1) return false;
    if (matrix[0].size() < 1) return false;
    
    int m = matrix.size();
    int n = matrix[0].size();
    int l = 0, r = m * n - 1;
    
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (matrix[mid / n][mid % n] == target)
        {
            return true;
        }
        else if (matrix[mid / n][mid % n] > target)
        {
            r = mid - 1;
        }
        else
        {
            l = mid + 1;
        }
    }
    
    return matrix[l / n][l % n] == target;
}

```

### 搜索二维矩阵

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.size() < 1) return false;
    if (matrix[0].size() < 1) return false;
    
    int row=matrix.size();
    int col=matrix[0].size();
    int i = 0, j = col - 1;
    while((i < row) && (j >= 0)) {
        
        if(matrix[i][j] == target)
            return true;
        
        if(matrix[i][j] > target)
            j--;  
        else if(matrix[i][j] < target)
            i++;
    }
    return false;
}

```

### 29. 两数相除

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

```
输入: dividend = 7, divisor = -3
输出: -2

```

```
int divide(int dividend, int divisor) {
    if(divisor == 1)
        return dividend;
    
    if(dividend == INT_MIN && divisor == INT_MIN)
        return 1;
    
    if(dividend == INT_MIN && abs(divisor) == 1)
        return INT_MAX;
    
    
    
    long long res = 0;
    long long n = abs((long long) dividend);
    long long d = abs((long long) divisor);
    
    while (n >= d)
    {
        long long tmp = d;
        long long time = 1;
        
        while ((tmp << 1) < n) {tmp <<= 1; time <<= 1; }
        
        n -= tmp;
        res += time;
    }
    
    if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))
        return -res;
    
    return res;
}

```

### 50. Pow(x, n)

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

```
double myPow(double x, int n) {
    double res = 1;
    long absN = abs((long) n);//需要特别注意幂是负数的情况
    
    while (absN > 0)
    {
        if ((absN & 1) == 1)
        {
            res *= x;
            absN -= 1;
        }
        else
        {
            x *= x;
            absN >>= 1;
        }
    }
    
    return n > 0 ? res : 1 / res;
}

```

### 69. x 的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

```

```
int mySqrt(int x) {
    if (x == 0) return 0;
    
    int l = 1, r = x;
    
    while (1)
    {
        int mid = l + (r - l) / 2;
        
        if (mid == (x / mid))
            return mid;
        
        if (mid > (x / mid))
        {
            r = mid - 1;
        }
        else 
        {
            if ((mid + 1) > x / (mid + 1))
                return mid;
            
            l = mid + 1;
        }
    }
    
    return l;
}

```

注意点：

- 本题必须特殊对待 mid * mid < x 的情况，我们可以允许 r = mid，但是绝对不允许出现 l = mid，因为当 l = r - 1 的时候会出现死循环

### 278. 第一个错误的版本

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。 

```

```
int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}

```

### 最小的第 k 个 数

```
void GetLeastNumbers_Solution1(int* input, int n, int* output, int k)
{
    if(input == nullptr || output == nullptr || k > n || n <= 0 || k <= 0)
        return;

    int start = 0;
    int end = n - 1;
    int index = Partition(input, n, start, end);
    while(index != k - 1)
    {
        if(index > k - 1)
        {
            end = index - 1;
            index = Partition(input, n, start, end);
        }
        else
        {
            start = index + 1;
            index = Partition(input, n, start, end);
        }
    }

    for(int i = 0; i < k; ++i)
        output[i] = input[i];
}


// ====================方法2====================
typedef multiset<int, std::greater<int> >            intSet;
typedef multiset<int, std::greater<int> >::iterator  setIterator;

void GetLeastNumbers_Solution2(const vector<int>& data, intSet& leastNumbers, int k)
{
    leastNumbers.clear();

    if(k < 1 || data.size() < k)
        return;

    vector<int>::const_iterator iter = data.begin();
    for(; iter != data.end(); ++ iter)
    {
        if((leastNumbers.size()) < k)
            leastNumbers.insert(*iter);

        else
        {
            setIterator iterGreatest = leastNumbers.begin();

            if(*iter < *(leastNumbers.begin()))
            {
                leastNumbers.erase(iterGreatest);
                leastNumbers.insert(*iter);
            }
        }
    }
}


```


## 交换排序

### 287. 寻找重复数

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

```
输入: [3,1,3,4,2]
输出: 3

```

```
int findDuplicate(vector<int>& nums) {
    int numsSize = nums.size();
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != nums[nums[i] - 1])
        {
            int index = nums[i] - 1;

            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }
    
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            return nums[i];
        }
    }
    
    return 0;
}

int findDuplicate(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    
    int slow = nums[0];
    int fast = nums[nums[0]];
    
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    
    fast = 0;
    while (slow != fast)
    {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return fast;
}

```

### 442. 数组中重复的数据

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]

```

```
vector<int> findDuplicates(vector<int>& nums) {
    int numsSize = nums.size();
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != nums[nums[i] - 1])
        {
            int index = nums[i] - 1;

            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }

    vector<int> ret;
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            ret.push_back(nums[i]);
        }
    }

    return ret;
}

```

### 448. 找到所有数组中消失的数字

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]

```


```
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize) {
    int *ret = (int *) malloc(numsSize * sizeof(int));
    for (int i = 0; i < numsSize; i++)
    {
        while (nums[i] != (i + 1))
        {
            int index = nums[i] - 1;
            
            if (nums[i] == nums[index])
                break;
            
            int tmp = nums[i];
            nums[i] = nums[index];
            nums[index] = tmp;
        }
    }
    
    *returnSize = 0;
    for (int i = 0; i < numsSize; i++)
    {
        if (nums[i] != (i + 1))
        {
            ret[(*returnSize)] = i + 1;
            (*returnSize)++;
        }
    }
    
    return ret;
}

```

### 41. 缺失的第一个正数

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

```
输入: [1,2,0]
输出: 3

```

```
int firstMissingPositive(vector<int>& nums) {
    if (nums.size() < 1) return 1;
    
    for (int i = 0; i < nums.size(); i++)
    {
        while (nums[i] > 0 && nums[i] <= nums.size() && nums[i] != nums[nums[i] - 1])
        {
            int tmp = nums[i];
            nums[i] = nums[tmp - 1];
            nums[tmp - 1] = tmp;
        }
    }
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] != (i + 1))
            return (i + 1);
    }
    
    return nums.size() + 1;
}

```

### 268. 缺失数字

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8

```

```
int missingNumber(int* nums, int numsSize) {
    int sum = numsSize * (numsSize + 1) / 2;
    
    int rsum = 0;
    for (int i = 0; i < numsSize; i++)
        rsum += nums[i];
    
    return (sum - rsum);
}

```


## 其他


### 169. 求众数

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

```
输入: [2,2,1,1,1,2,2]
输出: 2

```

```
int majorityElement(int* nums, int numsSize) {
    int element = INT_MIN;int count = 0;
    
    for (int i = 0; i < numsSize; i++)
    {
        if (count == 0)
        {
            element = nums[i];
            count++;
        } 
        else if (element == nums[i])
        {
            count++;
        } 
        else
        {
            count--;
        }
        
        if (count > numsSize / 2)
            return element;
    }
    
    return element;
}

int MoreThanHalfNum_Solution1(int* numbers, int length)
{
    if(CheckInvalidArray(numbers, length))
        return 0;
 
    int middle = length >> 1;
    int start = 0;
    int end = length - 1;
    int index = Partition(numbers, length, start, end);
    while(index != middle)
    {
        if(index > middle)
        {
            end = index - 1;
            index = Partition(numbers, length, start, end);
        }
        else
        {
            start = index + 1;
            index = Partition(numbers, length, start, end);
        }
    }
 
    int result = numbers[middle];
    if(!CheckMoreThanHalf(numbers, length, result))
        result = 0;

    return result;
}
```

### 229. 求众数 II

给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

```
输入: [1,1,1,3,3,2,2,2]
输出: [1,2]

```

```
vector<int> majorityElement(vector<int>& nums) {
    vector<int> res;
    if (nums.size() < 1) return res;
    
    int canA = nums[0];
    int canB = nums[0];
    int countA = 0;
    int countB = 0;
    
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] == canA)
        {
            countA++;
            continue;
        }
        
        if (nums[i] == canB)
        {
            countB++;
            continue;
        }
        
        if (countA == 0)
        {
            canA = nums[i];
            countA++;
            continue;
        }
        
        if (countB == 0)
        {
            canB = nums[i];
            countB++;
            continue;
        }
        
        countA--;
        countB--;
    }
    
    countA = 0;
    countB = 0;
    for (int i = 0; i < nums.size(); i++)
    {
        if (nums[i] == canA)
        {
            countA++;
            continue;
        }
        
        if (nums[i] == canB)
        {
            countB++;
            continue;
        }
    }
    
    if (countA > nums.size() / 3)
        res.push_back(canA);	
    
    if (countB > nums.size() / 3)
        res.push_back(canB);
    
    return res;
}

```

### 数组中的逆序数对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

采用归并排序算法：

```
int InversePairs(int* data, int length)
{
    if(data == nullptr || length < 0)
        return 0;

    int* copy = new int[length];
    for(int i = 0; i < length; ++i)
        copy[i] = data[i];

    int count = InversePairsCore(data, copy, 0, length - 1);
    delete[] copy;

    return count;
}

int InversePairsCore(int* data, int* copy, int start, int end)
{
    if(start == end)
    {
        copy[start] = data[start];
        return 0;
    }

    int length = (end - start) / 2;

    int left = InversePairsCore(copy, data, start, start + length);
    int right = InversePairsCore(copy, data, start + length + 1, end);

    // i初始化为前半段最后一个数字的下标
    int i = start + length;
    // j初始化为后半段最后一个数字的下标
    int j = end;
    int indexCopy = end;
    int count = 0;
    while(i >= start && j >= start + length + 1)
    {
        if(data[i] > data[j])
        {
            copy[indexCopy--] = data[i--];
            count += j - start - length;
        }
        else
        {
            copy[indexCopy--] = data[j--];
        }
    }

    for(; i >= start; --i)
        copy[indexCopy--] = data[i];

    for(; j >= start + length + 1; --j)
        copy[indexCopy--] = data[j];

    return left + right + count;
}

```

### 228. 汇总区间

给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。

```
输入: [0,2,3,4,6,8,9]
输出: ["0","2->4","6","8->9"]
解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。

```

```
vector<string> summaryRanges(vector<int>& nums) {
    vector<string> res;
    if (nums.size() < 1) return res;
    
    for (int i = 0; i < nums.size(); i++)
    {
        int start = i;
        int cur = nums[i];
        
        while (((i + 1) < nums.size()) && (nums[i + 1] == (cur + 1)))
        {
            cur += 1;
            i++;
        }
        
        string tmp;
        if (start == i)
        {
            tmp = std::to_string(nums[i]);
        }
        else
        {
            tmp = std::to_string(nums[start]);
            tmp += "->";
            tmp += std::to_string(nums[i]);
        }
        
        res.push_back(tmp);
    }
    
    return res;
}

```

### 扑克牌的顺子

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。

```
bool IsContinuous(int* numbers, int length)
{
    if(numbers == nullptr || length < 1)
        return false;

    qsort(numbers, length, sizeof(int), Compare);

    int numberOfZero = 0;
    int numberOfGap = 0;

    // 统计数组中0的个数
    for(int i = 0; i < length && numbers[i] == 0; ++i)
        ++numberOfZero;

    // 统计数组中的间隔数目
    int small = numberOfZero;
    int big = small + 1;
    while(big < length)
    {
        // 两个数相等，有对子，不可能是顺子
        if(numbers[small] == numbers[big])
            return false;

        numberOfGap += numbers[big] - numbers[small] - 1;
        small = big;
        ++big;
    }

    return (numberOfGap > numberOfZero) ? false : true;
}

```

### 约瑟夫环

输入：一个环形单向链表的头节点 head 和报数 m.

返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删除掉。

```
删除前     ---     删除后

…          ---      …

m - 2     ---     n - 2

m - 1    ---      n - 1

m         ----    无(因为编号被删除了)

m + 1     ---     1(因为下次就从这里报数了)

m + 2     ----     2

…         ----         …


假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。

注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.

```

```
public static Node josephusKill2(Node head, int m) {
 3        if(head == null || m < 1)
 4            return head;
 5        int n = 1;//统计一共有多少个节点
 6        Node last = head;
 7        while (last.next != head) {
 8            n++;
 9            last = last.next;
10        }
11        //直接用递归算出目的编号
12        int des = f(n, m);
13        //把目的节点取出来
14        while (--des != 0) {
15            head = head.next;
16        }
17        head.next = head;
18        return head;
19    }
20
21    private static int f(int n, int m) {
22        if (n == 1) {
23            return 1;
24        }
25        return (f(n - 1, m) + m - 1) % n + 1;
26    }

```

## 矩阵

### 48. 旋转图像

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


```

```
/*
 * clockwise rotate
 * first reverse up to down, then swap the symmetry 
 * 1 2 3     7 8 9     7 4 1
 * 4 5 6  => 4 5 6  => 8 5 2
 * 7 8 9     1 2 3     9 6 3
*/
void rotate(vector<vector<int> > &matrix) {
    reverse(matrix.begin(), matrix.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}

/*
 * anticlockwise rotate
 * first reverse left to right, then swap the symmetry
 * 1 2 3     3 2 1     3 6 9
 * 4 5 6  => 6 5 4  => 2 5 8
 * 7 8 9     9 8 7     1 4 7
*/
void anti_rotate(vector<vector<int> > &matrix) {
    for (auto vi : matrix) reverse(vi.begin(), vi.end());
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = i + 1; j < matrix[i].size(); ++j)
            swap(matrix[i][j], matrix[j][i]);
    }
}

```

### 54. 螺旋矩阵

给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]

```

```
vector<int> spiralOrder(vector<vector<int>>& matrix) {
    vector<int> res;
    if (matrix.size() < 1) return res;
    
    int r1 = 0, r2 = matrix.size() - 1;
    int c1 = 0, c2 = matrix[0].size() - 1;
    
    while (r1 <= r2 && c1 <= c2)
    {
        for (int c = c1; c <= c2; c++) res.push_back(matrix[r1][c]);
        for (int r = r1 + 1; r <= r2; r++) res.push_back(matrix[r][c2]);
        
        if (r1 < r2 && c1 < c2)
        {
            for (int c = c2 - 1; c >= c1; c--) res.push_back(matrix[r2][c]);
            for (int r = r2 - 1; r > r1; r--) res.push_back(matrix[r][c1]);
        }
        
        r1++;
        r2--;
        c1++;
        c2--;
    }
    
    return res;
}

```


### 59. 螺旋矩阵 II

给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

```
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```

```
vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> res(n, vector<int>(n, 0));
    
    int r1 = 0, r2 = n - 1;
    int c1 = 0, c2 = n - 1;
    int i = 1;
    while (r1 <= r2 && c1 <= c2)
    {
        for (int c = c1; c <= c2; c++) res[r1][c] = i++;
        for (int r = r1 + 1; r <= r2; r++) res[r][c2] = i++;
        
        if (r1 < r2 && c1 < c2)
        {
            for (int c = c2 - 1; c >= c1; c--) res[r2][c] = i++;
            for (int r = r2 - 1; r > r1; r--) res[r][c1] = i++;
        }
        
        r1++;
        r2--;
        c1++;
        c2--;
    }
    
    return res;
}

```

### 73. 矩阵置零


给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

```
输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

```

```
void setZeroes(vector<vector<int>>& matrix) {
    if (matrix.size() < 1) return;
    
    int m = matrix.size();
    int n = matrix[0].size();
    bool isRow = 0, isCol = 0;
    for (int j = 0; j < n; j++)
    {
        if (matrix[0][j] == 0)
            isRow = 1;
    }
    for (int j = 0; j < m; j++)
    {
        if (matrix[j][0] == 0)
            isCol = 1;
    }
    
    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            if (matrix[i][j] == 0)
            {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    
    for (int i = 1; i < m; i++)
    {
        if (matrix[i][0] == 0)
        {
            for (int j = 1; j < n; j++)
                matrix[i][j] = 0;
        }
    }
    
    for (int i = 1; i < n; i++)
    {
        if (matrix[0][i] == 0)
        {
            for (int j = 1; j < m; j++)
                matrix[j][i] = 0;
        }
    }
    
    if (isRow)
    {
        for (int j = 0; j < n; j++)
            matrix[0][j] = 0;
    }
    if (isCol)
    {
        for (int j = 0; j < m; j++)
            matrix[j][0] = 0;
    }
}

```

### 118. 杨辉三角

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

```
for (int i = 0; i < numRows; i++)
{
    for (int j = 0; j < i + 1; j++)
    {
        if (j == 0 || j == i) 
        {
           returnArray[i][j] = 1;
            continue;
        }
            
        returnArray[i][j] = returnArray[i - 1][j - 1] + returnArray[i - 1][j];
    }
}

```


