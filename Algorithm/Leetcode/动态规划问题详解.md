# 动态规划问题详解

## 简洁版动态规划

小节分析:

> 简洁版动态规划常常是只需要一次循环即可完成自底而上的题目，最为经典的就是爬楼梯问题
>
> 在该类问题中，我们通常只需要循环 1.2.3...n, 就可以得到到达 n 所的总可能数目或者最大利益值
> 
> 从动态规划的角度来说，1.2.3...n 就是达到 n 付出的代价，达到 i 的路径通常可能是 (i - 1)、(i - 2)...(i - j)，因此递归公式经常为 
> 
> dp[i] = dp[i - 1] + dp[i - 2] + ...+ dp[i - k] 或者
> 
> dp[i] = std::max(dp[i - 1] + s[i - 1], dp[i - 2] + s[i - 2])
> 
> 这点与经典的动态规划有所不同，经典动态规划 i 的结果常常由 (i - 1) 就可以得到，所付出的代价也往往是另一个维度的事务
> 
> dp[i][j] += dp[i - 1][j - k] 或者
> 
> 
> dp[i][j] = std::max(dp[i][j]，dp[i - 1][j - k] + w) 

### 70. Climbing Stairs 爬楼梯（楼梯问题）(个数)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

核心代码

```
tmp[0] = 0;tmp[1] = 1;tmp[2] = 2;
for (int i = 3; i <= n; i++)
{
    tmp[i] = tmp[i - 1] + tmp[i - 2];
}

```

### 746. Min Cost Climbing Stairs 使用最小花费爬楼梯（价值）

数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i] `(索引从0开始)`。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

```
Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.

```

核心代码:

```
ret[0] = 0; ret[1] = 0;
for (int i = 2; i <= costSize; i++)
{
    ret[i] = min(ret[i - 1] + cost[i - 1], ret[i - 2] + cost[i - 2]);
}
``` 

### 91. Decode Ways 解码方法（个数）

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26

```
给定一个只包含数字的非空字符串，请计算解码方法的总数。

```

输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

```

核心代码：

```
if (s[i] == '0') dp[i] = 0;
else dp[i] = dp[i - 1];
    
if (s[i - 1] == '1')
{
    dp[i] += (i >= 2 ? dp[i - 2] : 1);
    dp[i] %= M;
}
if (s[i - 1] == '2' && s[i] <= '6')
{
    dp[i] += (i >= 2 ? dp[i - 2] : 1);
    dp[i] %= M;
}
```
关键点分析：

> 原理：

>只要当前元素不是 0, 那么就可以单独作为一个解码的数字来对应字母，此时可以解码的方式等同于 dp[i - 1]
可以理解为, 当前元素仅仅是在字符串末尾添加一个字母，并不会影响字符串的可能数量

>只要当前元素和前一个元素组合起来小于 26，那么就可以把这两个元素看做一个元素，那么解码方式等同于 dp[i - 2]

>注意点：

>如果当前元素为 0, 那么只能和前一个元素结合，可以把 dp[i - 1] 当做 0

>如果当前元素和前一个元素组合超过 26，那么可以看做 dp[i - 2] 为 0

>边界条件:

>dp[0][0] = 1;

>如果 s[0] == '0'，那么直接返回 0



### 837. New 21 Game  新21点（个数）

爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

```
输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。


```

核心代码：

```
double new21Game(int N, int K, int W) {
    if (K == 0 || N >= (K + W)) return 1.0;
    
    double sum = 0.0;
    double dp[N + 1] = {0};
    for (int i = 0; i < N + 1; i++) dp[i] = 0;
    
    double ret = 0;
    dp[0] = 1;
    for (int i = 1; i < N + 1; i++) {
        for (int j = 1; j <= W; j++) {
            if (i > j && (i - j) < K) dp[i] += (dp[i - j] / W);
            else if (i == j) dp[i] += (1.0 / W);
        }
        
        if (i >= K) ret += dp[i];
    }
    
    return ret;
}
```

关键点分析：

> 原理：

> 本题可以看做是爬楼梯的高阶版本

>爬楼梯只有迈一步和迈两步

>本题中可以迈 1.2.3...W 步

>因此 dp[i] = (dp[i - 1] + dp[i - 2] + ...+ dp[i - j] +... + dp[i - K]) / W
    
>当 i 小于 W，可以先迈小步到 dp[i - j]，然后再迈 j 步，也可以一步迈到目的地 i

>当 i 大于 W 的时候，只能通过 dp[i - j] 来到达 i
如果想达到目的地 i，就不能迈比 i 还大的步，因此 j 需要 std::min(i, W)
    
>注意点：

>当迈小步 dp[i - j] 的时候，如果小步已经达到 K，那么爬楼梯即结束，因此不会再次迈 j 步，因此 dp[i] 不可能由 dp[i - j] 阶梯而来

>边界条件：

>K 为 0 或者 N 过大，直接返回 1 即可


### 903. DI 序列的有效排列

我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）
有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7.

```
输入："DID"
输出：5
解释：
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)

```

核心代码

```
int numPermsDISequence(string S) {
    int mod=1000000007;
    
    vector<vector<int>> dp(S.size() + 1, vector<int>(S.size() + 1, 0));
    //dp[0][0] = 1;
    for(int i = 0; i<=S.size(); i++) dp[0][i] = 1;
    
    for (int i = 1; i <= S.size(); i++)
    {
        for (int j = 0; j <= i; j++)
        {
            if (S[i - 1] == 'D')
            {
                for (int k = j; k < i; k++)
                    dp[i][j] = (dp[i][j] + dp[i - 1][k] % mod) % mod;
            }
            else
            {
                for (int k = 0; k < j; k++)
                    dp[i][j] = (dp[i][j] + dp[i - 1][k] % mod) % mod;
            }
        }
    }
    
    int res = 0;
    for (int i = 0; i <= S.size(); i++)
    {
        res = (res + dp[S.size()][i] % mod) % mod;
    }
    
    return res;
}

```

关键点

> 本题很难看出是阶梯类型的题目，但是深层次下有一定的共同性
> 
> 当 S[i] 是 D 时，在数组中，位置为 i 的地方，P[i] 为 j 的个数就是 i-1 位置上，P[i-1] 大于 j 的个数之和
> 
> 类似的，S[i] 是 I 的时候也是类似情况。

## 传统 0-1 背包问题

小节分析：

> 所谓的 0-1 背包问题就是给定 1.2.3...n 个元素，从中选出若干个元素来达到某种目标，每个元素都面临着选或者不选两种抉择，这就是 0-1 背包问题
> 
> 这类问题最简单的方法是使用递归方法穷举遍历所有的可能性，但是其中走了很多重复的路径。
> 
> 动态规划的作用就是找出路径相交的节点，选择最优方法，[避免走重复无用的路径](https://www.zhihu.com/question/39948290/answer/83942329)
> 


### 494. Target Sum 目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```
输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

```
核心代码

```
int findTargetSumWays(vector<int>& nums, int S) {
        
    int sum=0;
    for(auto n:nums) sum+=n;
    
    if(sum<S || (sum+S)%2!=0) return 0;
    
    return subsetSum(nums, (sum+S) >> 1);
}
    
int subsetSum(vector<int>& nums, int S)
{
    int size = nums.size();
    vector<int> tmp(S + 1, 0);
    vector<vector<int>> dp(size, tmp);
    dp[0][nums[0]] = 1;
    dp[0][0] = nums[0] == 0 ? 2 : 1;
    
    for (int i = 1; i < size; i++)
    {
        for (int j = 0; j <= S; j++)
        {
            if (j >= nums[i]) 
                dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j];
                //dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]; 完全背包算法
            else 
                dp[i][j] = dp[i - 1][j];     
        }
    }
    
    return dp[size - 1][S];
}
```

关键点分析：

> 原理
> 
> a + b + c + ... + n = sum
> 
> a - b + c + ... - n = s
> 
> a + c + ... + = (sum + s) / 2
> 
> 直接去计算元素前 + - 符号毫无疑问会极大加大算法复杂度，可以利用上述公式简化为 0-1 背包问题，选出特定的元素 a、c 等等元素来满足目标 (sum + s) / 2
> 
> 注意点
> 
> dp[i - 1][j - nums[i]] 是 0-1 背包的经典方式，而 dp[i][j - nums[i]] 却是完全背包的经典方式，原因在于 dp[i][j - nums[i]] 很可能包含了当前 i 的价值，也就是很有可能是 dp[i - 1][j - nums[i] - nums[i]]
> 
> 就是说重复选择了当前的元素 i，因此在节省内存的情况下， 一维 0-1 背包经常倒序遍历，以保证 j - nums[i] 的值是 i - 1 元素而来，而不是已经经过了 i 元素叠加而来。
> 
> 边界点
> 
> 如果 S 过大，或者 (sum + s) / 2 不是偶数，返回 false
> 



### 474. Ones and Zeroes 一和零

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

注意:

- 给定 0 和 1 的数量都不会超过 100。
- 给定字符串数组的长度不会超过 600

```

输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。

```

核心代码：

```
for (int i = 0; i < N; i++)
{
    for (int j = m; j >= mm[i]; j--)
    {
        for (int k = n; k >= nn[i]; k--)
        {
            dp[j][k] = max(dp[j - mm[i]][k - nn[i]] + 1, dp[j][k]);
        }
    }
}
```

关键点分析：

> 原理
> 
> 这类问题仍然是 0-1 背包问题，但是所消耗的代价却是二维的
> 
> 因此相应的循环也是二维的
> 

### 871. 最低加油次数

汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。

沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。

假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。

当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。

为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。

注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。

```
输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
输出：2
解释：
我们出发时有 10 升燃料。
我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。
然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），
并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。
我们沿途在1两个加油站停靠，所以返回 2 。
```


```
for (int i = 0; i < n; i++)
{
    for (int j = 0; j <= i + 1; j++)
    {
        if (dp[i][j] >= stations[i][0])
            dp[i + 1][j] = dp[i][j];
            
        if (j >= 1 && dp[i][j - 1] >= stations[i][0])
        {
            dp[i + 1][j] = std::max(dp[i][j], dp[i][j - 1] + stations[i][1]);
        }
    }
}

```

关键点：

> 本题不太容易看出来是 0-1 背包问题，因为限制条件汽油量里程数并不是固定不变的，而是随着 i 的变化而变化、
> 
> 因而题解中选取的 j 并不是限制条件汽油量里程数，而是题目中所需要求解的加油次数，这个是很难想到的。
> 
> 在 i 位置加了 j 次油有两种可能，一种可能是 i-1 位置已经 j 次油，i 位置不需要加油；还有一种可能是 i-1 位置加了 j-1 次油，在 i 位置又加了一次。这个是常规的 0-1 背包考虑的方法，但是我们需要加上里程数的限制条件
> 
> 只有当 i-1 位置加了 j 次油可以到达 stations[i] 的时候，i 位置才能继承 j 次油的里程数
> 
> 只有 i-1 位置加了 j-1 次油可以到达 stations[i] 的时候, i 位置才有可能再次加第 j 次油

### 879. 盈利计划

帮派里有 G 名成员，他们可能犯下各种各样的罪行。

第 i 种犯罪会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。

让我们把这些犯罪的任何子集称为盈利计划，该计划至少产生 P 的利润。

有多少种方案可以选择？因为答案很大，所以返回它模 10^9 + 7 的值。

```
输入：G = 5, P = 3, group = [2,2], profit = [2,3]
输出：2
解释： 
至少产生 3 的利润，该帮派可以犯下罪 0 和罪 1 ，或仅犯下罪 1 。
总的来说，有两种方案。

```

核心代码

```
for (int i = 1; i < group.size(); i++)
{
    //dp[i] = dp[i - 1];
    for (int jp = 0; jp <= P; ++jp)
        for (int jg = 0; jg <= G; ++jg)
            dp[i][jg][jp] = dp[i - 1][jg][jp];
    
    for (int j = group[i]; j <= G; j++)
    {
        for (int k = 0; k <= P; k++)
        {
            long tmp = k + profit[i];
            
            if (tmp >= P)
            {
                dp[i][j][P] += dp[i - 1][j - group[i]][k];
                res += dp[i - 1][j - group[i]][k];
                
                res %= m;
                dp[i][j][P] %= m;
            }
            else
            {
                dp[i][j][tmp] += dp[i - 1][j - group[i]][k];
                
                dp[i][j][tmp] %= m;
            }
        }             
    }
}

```

关键点

> 本题可以算是标准的 0-1 背包问题，该题的特色是想要计算大于 P 价值的个数

## 完全背包


### 322. Coin Change 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1

```

核心代码

```
for (int i = 0; i < coins.size(); i++)
{
    for (int j = coins[i]; j <= amount; j++)
    {
        dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);
    }
}
```

### 377. Combination Sum IV 组合总和 Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

```
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

```

核心代码：

```
int combinationSum4(vector<int>& nums, int target) {
    int N = nums.size();
    int dp[target + 1] = {0};
    dp[0] = 1;
    
    for (int i = 1; i <= target; ++i) {
        for (int j = 0; j < N; ++j) {
            if (nums[j] <= i) {
                dp[i] += dp[i - nums[j]];
            }
        }
    }
    
    return dp[target];
    
}
```

关键点分析：

> 本题与完全背包稍微有些不同，因为所有可能的组合中，不同的元素直接调换顺序会增加组合数量
> 
> 普通的完全背包中，两层循环的顺序是无关的，原因是求解最大值，所以元素的顺序无关
> 
> 但是涉及到组合数量的时候，两层循环的顺序是至关重要的
> 

## 类股票问题

本节小结

> 类股票问题和传统的动态规划相比，相同点是 i 位置面临着选择，比如股票就是要选择买还是选择卖，还是静观其变
> 
> 然而此类问题和传统动态规划很显著的不同在于，我们要计算出做出每个选择(dp[i][0]、dp[i][1])的可能个数，或者最大的价值，i 位置的选择会基于 i-1 的各种选择综合考虑(dp[i][0] + dp[i][1])；而对于传统动态规划来说，只需要考虑其中一种情况即可
>  
> 造成这类不同的常见原因一般是由于 i 位置与 i-1 位置的互斥条件，例如股票问题中，i 位置想要买股票，那么 i-1 位置必须卖股票，或者小偷问题中不允许偷相邻两个房间，不允许相邻位数都是 1 等等条件
> 
> 对于传统的动态规划来说，解决多选择问题常常利用代价累计(例如背包容量累计)的方式，但是代价累计无法解决互斥条件，因而需要计算出各种互斥选择的个数或最大价值，然后在 i 位置进行综合考虑。
> 

### 188. Best Time to Buy and Sell Stock IV 买卖股票的最佳时机 IV (价值)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。


```
输入: [3,2,6,5,0,3], k = 2
输出: 7
解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

```


核心代码：

```
int maxProfit(vector<int>& p, int res = 0) {
    for (int i = 1; i < p.size(); ++i) res += max(0, p[i] - p[i - 1]);
    return res;
}
// 股票问题 II 问题解法

int maxProfit(int k, vector<int>& prices) {
    if (k >= prices.size() / 2) return maxProfit(prices);
    
    ...
        
    hold[0][0] = -prices[0];unhold[0][0] = 0;
    for (int i = 1; i < prices.size(); i++)
    {
        for (int j = 0; j < k; j++)
        {
            if (j >= 1) hold[i][j] = std::max(hold[i - 1][j], unhold[i][j - 1] - prices[i]);
            else hold[i][j] = std::max(hold[i - 1][j], - prices[i]);
            
            unhold[i][j] = std::max(unhold[i - 1][j], hold[i - 1][j] + prices[i]);
        }
    }
  
    ...
}
```

关键点：

> 原理
> 
> 股票问题使用两个数组，分别代表在 i 元素上进行买操作和卖操作，hold[i][j] 说明在 i 元素进行第 j 次买操作，unhold[i][j] 代表在 i 元素进行第 j 次卖操作
> 
> 如果想要在 i 元素进行第 j 次买操作，那么有两种情况，那就是 i - 1 的时候已经进行了 j 次买操作；或者 i 
> 元素上已进行了 j - 1 次卖操作，这次再买回来，因为股票只有卖掉之后才能买
> 
> 同理，如果想要在 i 元素进行第 j 次卖操作也是如此
> 
> 注意点：
> 
> 当 j == 0 的时候，这个时候在 i 元素买入，实际的含义就是第一次购买，因此就是 - prices[i]
> 

### 121. Best Time to Buy and Sell Stock 买卖股票的最佳时机(价值)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

```

核心代码

```
for (int i = 0; i < pricesSize; i++)
{
    minNum = minNum < prices[i] ? minNum : prices[i];
    
    int tmp = prices[i] - minNum;
    maxdiff = maxdiff > tmp ? maxdiff : tmp;
}

```

### 309. Best Time to Buy and Sell Stock with Cooldown 最佳买卖股票时机含冷冻期(价值)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。


```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

```

核心代码

```
hold[0] = -prices[0];
unhold[0] = 0;
        
int ret = 0;
for (int i = 1; i < M; i++)
{
    unhold[i] = max(unhold[i - 1], hold[i - 1] + prices[i]);
    
    if (i == 1) 
        hold[i] = max(-prices[0], - prices[1]);
    else 
        hold[i] = max(unhold[i - 2] - prices[i], hold[i - 1]); 
    
    if (ret < unhold[i]) ret = unhold[i];
}

```


### 714. Best Time to Buy and Sell Stock with Transaction Fee 买卖股票的最佳时机含手续费(价值)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

核心代码

```
hold[0] = -prices[0];

for (int i = 1; i < n; i++) { 
    unhold[i] = max(unhold[i - 1], hold[i - 1] + prices[i] - fee);
    hold[i] = max(hold[i - 1], unhold[i - 1] - prices[i]);
} 

```

关键点：

> 无论是冷冻期还是手续费，hold 和 unhold 数组都不再是二维数组，而是一个和 i 元素相关的一维数组，因为此时相当于 k 是无限大的情况
> 
> 该类题型需要注意初始 i == 0 的情况

### 213. House Robber II 打家劫舍 II（价值）

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

核心代码：

```
vector<int> tmp1(nums.begin(), nums.end() - 1);
vector<int> tmp2(nums.begin() + 1, nums.end());
    
return max(rob1(tmp1), rob1(tmp2));

...

int rob1(vector<int> nums)
{
    int N = nums.size();
    if (N == 1) return nums[0];
    if (N == 2) return (nums[1] > nums[0]) ? nums[1] : nums[0];
    
    // int maxsum[N] = {0};
    // maxsum[0] = nums[0];
    // maxsum[1] = (nums[1] > nums[0]) ? nums[1] : nums[0];
    // for (int i = 2; i < N; i++)
    // {
    //     maxsum[i] = (maxsum[i - 2] + nums[i]) > maxsum[i - 1] ? (maxsum[i - 2] + nums[i]) : maxsum[i - 1];
    // }
    vector<int> rob(N, 0);
    vector<int> nonRob(N, 0);
    
    rob[0] = nums[0];nonRob[0] = 0;
    for (int i = 1; i < N; i++) {
        rob[i] = std::max(rob[i - 1], nonRob[i - 1] + nums[i]);
        nonRob[i] = std::max(nonRob[i - 1], rob[i - 1]);
    }
    
    return std::max(rob[N - 1], nonRob[N - 1]);
}
```

关键点：

> 746 题目和 198 题目非常相似，都是简洁版动态规划计算最大值最小值的典型题目
> 
> 此类题目只需要判断当前位置 i 是由 i-1 还是 i-2 而来价值最大或最小即可
> 
> 198 题目稍微有些特殊，因为是否可以走当前 i 位置是由 i-1 和 i-2 决定的，而不是传统的 i 位置来决定走 i-1 还是 i-2

相似题型：

> 740 Delete and Earn  删除与获得点数
> 

>```
输入: nums = [2, 2, 3, 3, 3, 4]
输出: 9
解释: 
删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。

>```
>
>```
>
int deleteAndEarn(vector<int>& nums) {
        int N = nums.size();
        int count[10001] = {0};
>
        for (int i = 0; i < N; i++)
        {
            count[nums[i]] += nums[i];
        }
>  
        int unhold[10001] = {0};
        int hold[10001] = {0};
        hold[1] = count[1];
        for (int i = 2; i < 10001; i++)
        {
            hold[i] = std::max(hold[i - 1], unhold[i - 1] + count[i]);
            unhold[i] = std::max(unhold[i - 1], hold[i - 1]);
        }
>        
        return hold[10000];
}
>```

### 801. Minimum Swaps To Make Sequences Increasing 使序列递增的最小交换次数(个数)

我们有两个长度相等且不为空的整型数组 A 和 B 。

我们可以交换 A[i] 和 B[i] 的元素。注意这两个元素在各自的序列中应该处于相同的位置。

在交换过一些元素之后，数组 A 和 B 都应该是严格递增的（数组严格递增的条件仅为A[0] < A[1] < A[2] < ... < A[A.length - 1]）。

给定数组 A 和 B ，请返回使得两个数组均保持严格递增状态的最小交换次数。假设给定的输入总是有效的。

```
示例:
输入: A = [1,3,5,4], B = [1,2,3,7]
输出: 1
解释: 
交换 A[3] 和 B[3] 后，两个数组如下:
A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]
两个数组均为严格递增的。
```
核心代码：

```
int minSwap(vector<int>& A, vector<int>& B) {
    int n1 = 0, s1 = 1, n2, s2;
    
    for (int i = 1; i < A.size(); i++)
    {
        int n2 = INT_MAX, s2 = INT_MAX;
        if (A[i] > A[i - 1] && B[i] > B[i - 1])
        {
            n2 = n1;
            s2 = s1 + 1;
        }
        
        if (A[i] > B[i - 1] && B[i] > A[i - 1])
        {
            n2 = std::min(n2, s1);
            s2 = std::min(s2, n1 + 1);
        }
        
        n1 = n2;
        s1 = s2;
    }
    
    return std::min(n1, n2);
}

```
关键点：

> 本题中每个元素 i 位置都可以选择调换 s[i] 和保持原状 n[i]
> 
> 反转分为两种情况，只有 i 位置、i-1 位置单个反转或者 i 与 i-1 一起反转
> 
> 当两个数组都是升序的时候，我们如果想要保持原状，那么就 i - 1 也保持原状；想要反转的话， i-1 也要反转
> 
> 两个数组中, (A[i] > B[i - 1] && B[i] > A[i - 1]), 说明此时 i 位置、i-1 位置可以单个进行反转

### 790. Domino and Tromino Tiling 多米诺和托米诺平铺（个数）

有两种形状的瓷砖：一种是 2x1 的多米诺形，另一种是形如 "L" 的托米诺形。两种形状都可以旋转。

```
XX  <- 多米诺

XX  <- "L" 托米诺
X

```

```
示例:
输入: 3
输出: 5
解释: 
下面列出了五种不同的方法，不同字母代表不同瓷砖：
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY

```

核心代码：

```
dp[0][0] = 1;dp[0][1] = 0;
dp[1][0] = 1;dp[1][1] = 2;
for (int i = 2; i <= N; i++){
    dp[i][0] = (dp[i - 1][0] + dp[i - 2][0] + dp[i - 2][1]) % MOD;
    dp[i][1] = (2 * dp[i - 1][0] + dp[i - 1][1]) % MOD;
}

```
关键点：

> 原理：
>
>  我们可以把多米诺分为5种：横向、双横向、纵向、L型、7型
> 
> 我们可以把 i 位置上的形状分为两种：有突出的和无突出的
> 
> 很明显，题目让我们求的就是 N 位置无突出的铺砖方法
> 
> 如果想要 i 位置上无突出，那么可能性有三种：
> 
> >(1) 在 i-1 无突出上添加一个纵向多米诺
> >
> >(2) 在 i-2 无突出上添加双横向多米诺
> >
> >(3) 在 i-2 有突出上添加 L 型或者 7 型，构成 L7 或者 7L
> 
> 如果想要 i 位置上有突出，也有三种可能：
> 
> > (1) 在 i-1 无突出上添加 7
> > 
> > (2) 在 i-1 无突出上添加 L
> > 
> > (3) 在 i-1 有突出上添加单横向多米诺
> 
> 注意点：
> 
> 初始条件：dp[1][1] = 2

### *552. 学生出勤记录 II

给定一个正整数 n，返回长度为 n 的所有可被视为可奖励的出勤记录的数量。 答案可能非常大，你只需返回结果mod 109 + 7的值。

学生出勤记录是只包含以下三个字符的字符串：

'A' : Absent，缺勤
'L' : Late，迟到
'P' : Present，到场
如果记录不包含多于一个'A'（缺勤）或超过两个连续的'L'（迟到），则该记录被视为可奖励的。

核心代码

```
int checkRecord(int n) {
    int m = 1000000007;
    
    vector<int> adp(n, 0);
    vector<int> ldp(n, 0);
    vector<int> pdp(n, 0);
    
    pdp[0] = 1;
    ldp[0] = 1;
    adp[0] = 1;
    
    ldp[1] = 3;
    adp[1] = 2;
    
    adp[2] = 4;
    
    for (int i = 1; i < n; i++)
    {
        pdp[i] = ((adp[i - 1] % m + ldp[i - 1] % m) % m + pdp[i - 1] % m) % m;
        if (i >= 2) ldp[i] = ((pdp[i - 1] % m + adp[i - 1] % m) % m + (pdp[i - 2] % m + adp[i - 2] % m) % m) % m;
        
        if (i >= 3) adp[i] = ((adp[i - 1] % m + adp[i - 2] % m) % m + adp[i - 3] % m) % m;
    }
    
    return ((pdp[n - 1] % m + ldp[n - 1] % m) % m + adp[n - 1] % m) % m;
}

```
关键点

> 如果 i 位置想要设置 P，那么 i-1 位置可以是 P A L 任何一个
>  
> 如果 i 位置想要设置 L，那么 i-1 位置可以是 P A；也可以是 L，但是要求 i-2 必须不能是 L
> 
> 最麻烦的是 i 位置想要设置为 A，这个时候 i-1 位置可以是 nonAP，也可以是 nonAL，难的是我们不知道这个 nonAP/nonAL 怎么获取
> 
> 换一个角度来想，nonAP 的前面可以设置 PPA，也可以设置 LPA，这个其实是个 nonAA 是相同的，所以 nonAP=nonAA
> 
> 进一步分析 nonAL 的前面可以是 PLA，也可以是 PLLA
> 
> 因此 i 位置设置为 A 的可能组合是：PA、PLA、PLLA 三种，由于 nonAP 的概率和 nonAA 概率是一个，所以最后可得 A[i-1] + A[i-2] + A[i-3]

## 连续子序列

本节小节

> 连续子序列的问题有个万能的方法，那就是使用 len 进行双重循环，基本可以解决大部分问题，但是常常并不是最优解
> 
> 还有个方法，也是双重循环，两个指针一前一后
> 
> 如果想要高效率，那么就需要找出规律，一次循环即可，例如最大和，最大乘积，等差数列个数，特定字符串个数等等

### 647. Palindromic Substrings 回文子串(个数)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
      
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。

```
输入: "aaa"
输出: 6
说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".

```

核心代码

```
int countSubstrings(string s) {
    int N = s.size();
    int sum = s.size();
    int dp[N][N] = {0};
    
    for (int i = 0; i < N; i++) {dp[i][i] = 1;}
    for (int i = 0; i < N - 1; i++)
    {
        if (s[i] == s[i + 1])
        {
            dp[i][i + 1] = 1; sum++;
        }
    }
    
    for (int len = 3; len <= N; len++)
    {
        for (int i = 0; i < N; i++)
        {
            int left = i;
            int right = i + len - 1;
            
            if (left >=0 && right < N && dp[left + 1][right - 1] && s[left] == s[right])
            {
                dp[left][right] = 1;
                sum++;
            }
        }
    }
    
    return sum;
}

```

关键点：

> 回文子串的问题一般可以分为两种：求总个数和求最长回文；还可以分为连续子串还是非连续子串
> 
> 对于回文子串的问题，最简单的就是连续子序列的情况，只需要判断出 dp[i + 1][j - 1] 是回文子串，s[i] == s[j] 相同即可

### 5. Longest Palindromic Substring 最长回文子串(价值)

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

```

核心代码：

```
for (int len = 3; len <= s.size(); len++)
{
    for (int i = 0; i < s.size(); i++)
    {
        int j = i + len - 1;
        
        if (j < s.size() && s[i] == s[j] && dp[i + 1][j - 1] > 0)
        {
            dp[i][j] = dp[i + 1][j - 1] + 2;
            
            if ((j - i) > (end - start))
            {
                start = i;end = j;
            }
        }
    }
}

```
### 516. Longest Palindromic Subsequence 最长回文子序列(价值)

给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

```
示例 1:
输入:
"bbbab"

输出:
4

一个可能的最长回文子序列为 "bbbb"。

```

核心代码：

```
for (int len = 2; len <= N; len++)
{
    for (int i = 0; i < N - 1; i++)
    {
        int j = i + len - 1;
        
        if (j < N)
        {
            if (s[i] == s[j])
            {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            }
            else
            {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
}

```
关键点：

> 有意思的是，即使本题并不是连续子串，仍然可以使用连续子串的方法来计算最大回文子序列
> 
> 然而，对于回文子序列的个数来说，就很麻烦，如下题目


### 730. 统计不同回文子字符串(个数)

给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。

通过从 S 中删除 0 个或多个字符来获得子字符序列。

如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。

如果对于某个  i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。

```
输入：
S = 'bccb'
输出：6
解释：
6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。

```

核心代码：

```
for (int len = 2; len <= n; len++)
{
    for (int i = 0; i <= n - len; i++)
    {
        int j = i + len - 1;
        if (S[i] == S[j])
        {
            if (rightnext[i] < leftnext[j]){
                dp[i][j] = dp[i + 1][j - 1] * 2 - dp[rightnext[i] + 1][leftnext[j] - 1];
            }
            
            if (rightnext[i] == leftnext[j])
            {
                dp[i][j] = dp[i + 1][j - 1] * 2 + 1;
            }
            
            if (rightnext[i] > leftnext[j])
            {
                dp[i][j] = dp[i + 1][j - 1] * 2 + 2;
            }
        }
        else
        {
            dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
        }
        
        dp[i][j] = dp[i][j] < 0 ? dp[i][j] + 1000000007 : dp[i][j] % 1000000007;
    }
}


```

关键点：

> 对于连续子序列的回文子串，s[i] == s[j] 只能说明回文子串增加了 1 个；但是对于非连续的子序列来说，s[i] == s[j] 就相当于数量翻倍，再加上 s[i]、s[j]、s[i]s[j]，也就是 2 * dp[i + 1][j - 1] + 3
> 
> 对于本题来说，不允许出现重复的回文子串，那么就只剩下s[i]、s[i]s[j]，也就是 2 * dp[i + 1][j - 1] + 2
> 
> 如果 i+1 和 j-1 中存在一个 s[i] 这个字符，那么还要就剩下了 s[i]s[j]，也就是 2 * dp[i + 1][j - 1] + 1
> 
> 如果 i+1 和 j-1 中存在多个 s[i] 这个字符，那么 s[i]s[j] 这个回文子串也要减下去，除此之外，还要减下去重复的 dp[rightnext[i] + 1][leftnext[j] - 1]

### 472. 连接词

给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。

连接词的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。

```
输入: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

输出: ["catsdogcats","dogcatsdog","ratcatdogcat"]

解释: "catsdogcats"由"cats", "dog" 和 "cats"组成; 
     "dogcatsdog"由"dog", "cats"和"dog"组成; 
     "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
```

核心代码：

```
vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
    std::sort(words.begin(), words.end(), [](string& s1, string& s2) {
        int l1 = s1.size();
        int l2 = s2.size();
        return (l1 - l2) < 0 ? 1 : 0;
    });
    
    set<string> preWords;
    vector<string> res;
    for (int i = 0; i < words.size(); i++)
    {
        string word = words[i];
        if (canConcate(word, preWords))
        {
            res.push_back(word);
        }
        
        preWords.insert(word);
    }
    
    return res;
}
    
bool canConcate(string& word, set<string>& preWords)
{
    if (! preWords.size()) return false;
    
    vector<bool> dp(word.size(), 0);
    
    for (int i = 0; i < word.size(); i++)
    {
        for (int j = 0; j <= i; j++)
        {
            if (j >= 1 && ! dp[j - 1])
                continue;
            
            string subString(word.begin() + j, word.begin() + i + 1);
            if (preWords.find(subString) != preWords.end())
            {
                dp[i] = 1;
                break;
            }    
        }
    }
    
    return dp[word.size() - 1];
}

```

关键点：

> 原理
> 
> 这种连续子串的另一种遍历方式，虽然也是双重循环，特别适合这种单词拼接的问题
> 
> 注意点：
> 
> if (j >= 1 && ! dp[j - 1]) 这个很重要


### 140 单词拆分 II

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

```
输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]

```

核心代码

```
vector<string> wordBreak(string s, vector<string>& wordDict) {
    vector<int> tmp;
    vector<vector<int>> dp(s.size(), tmp);
    
    for (int i = 0; i < s.size(); i++)
    {
        for (int j = 0; j < wordDict.size(); j++)
        {
            string word = wordDict[j];
            if ((i - word.size() + 1) == 0)
            {
                string s_str(s.begin(), s.begin() + i + 1);
                if (word == s_str)
                {
                    dp[i].push_back(-1);
                }
            }
            else if ((i - word.size()) >= 0 && dp[i - word.size()].size())
            {
                string s_str(s.begin() + i - word.size() + 1, s.begin() + i + 1);
                if (word == s_str)
                {
                    dp[i].push_back(i - word.size());
                }
            }
        }
    }
    
    vector<string> res;
    string str = "";
    backtrace(s, dp, s.size() - 1, str, res);
    
    return res;
}
    
void backtrace(string s, vector<vector<int>> dp, int current, string str, vector<string>& res)
{
    if (current == -1) {res.push_back(str); return;}
    
    for (int i = 0; i < dp[current].size(); i++)
    {
        int index = dp[current][i];
        
        string temp_str(s.begin() + index + 1, s.begin() + current + 1);
        if (str.size()) temp_str = temp_str + " " + str;
        
        backtrace(s, dp, index, temp_str, res);
    }
    
    return;
}

```
关键点:

> 这道题的难点在于存在需要做个回溯

### 11. 盛最多水的容器

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

```
输入: [1,8,6,2,5,4,8,3,7]
输出: 49

```

核心代码

```
int maxArea(vector<int>& height) {
    int res = 0;
    
    int l = 0, r = height.size() - 1;
    while (l < r)
    {
        res = std::max(res, std::min(height[l], height[r]) * (r - l));
        
        if (height[l] < height[r])
            l++;
        else
            r--;
    }
    
    return res;
}

```

### 53. Maximum Subarray 最大子序和(价值)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。


```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

```
核心代码：

```
int maxSubArray(int* nums, int numsSize) {
    int sum = 0, max = INT_MIN;
    
    for (int i = 0; i < numsSize; i++)
    {
        sum += nums[i];
        
        if (sum < nums[i]) sum = nums[i];
        
        max = max > sum ? max : sum;
    }
    
    return max;
}

```
### 152. Maximum Product Subarray 乘积最大子序列(价值)

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

```

核心代码：

```
int maxProduct(vector<int>& nums) {
    if (nums.size() < 1) return 0;
    int maxSum = nums[0];
    int minSum = nums[0];
    int ret = nums[0];
    int preMax = -1;
    int preMin = -1;
    
    for (int i = 1; i < nums.size(); i++)
    {
        preMax = maxSum;
        preMin = minSum;
        
        maxSum = std::max(nums[i], std::max(nums[i] * preMax, nums[i] * preMin));
        minSum = std::min(nums[i], std::min(nums[i] * preMax, nums[i] * preMin));
        
        ret = std::max(maxSum, ret);
    }
    
    return ret;
}

```

### 413. Arithmetic Slices 等差数列划分(个数)

数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0<=P<Q<N 。

如果满足以下条件，则称子数组(P, Q)为等差数组：

元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 < Q 。

函数要返回数组 A 中所有为等差数组的子数组个数。


```
A = [1, 2, 3, 4]

返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。

```
核心代码：

```
int numberOfArithmeticSlices(vector<int>& A) {
    if (A.size() < 3) return 0;
    int interval = A[1] - A[0];
    int N = A.size();
    
    int sum = 0;
    int dp[N] = {0};
    for (int i = 2; i < N; i++)
    {
        if ((A[i - 1] - A[i - 2]) == (A[i] - A[i - 1]))
        {
            dp[i] = dp[i - 1] + 1;
        }
        
        sum += dp[i];
    }
    
    return sum;
}
```

关键点：

> 本题的关键点就在于连续子串的数量，实际上是 1+2+3+4+...+n

### 467. Unique Substrings in Wraparound String 环绕字符串中唯一的子字符串(个数)

把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 s 看起来是这样的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". 

现在我们有了另一个字符串 p 。你需要的是找出 s 中有多少个唯一的 p 的非空子串，尤其是当你的输入是字符串 p ，你需要输出字符串 s 中 p 的不同的非空子串的数目。 

注意: p 仅由小写的英文字母组成，p 的大小可能超过 10000。

```
输入: "zab"
输出: 6
解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.

```

核心代码

```
int findSubstringInWraproundString(string p) {
    if (p.size() < 1) return 0;
    if (p.size() == 1) return 1;
    int dp[p.size()] = {0};
    for (int i = 0; i < p.size(); i++) dp[i] = 1;
    
    vector<int> vec(26);vec[p[0] - 'a'] = 1;
    for (int i = 1; i < p.size(); i++)
    {
        if ((p[i] - p[i - 1]) == 1) dp[i] = dp[i - 1] + 1;
        
        if ((p[i] == 'a') && (p[i - 1] == 'z')) dp[i] = dp[i - 1] + 1;
        
        vec[p[i] - 'a'] = std::max(dp[i], vec[p[i] - 'a']);
    }
    
    int sum = 0;
    for (int i = 0; i < 26; i++) sum += vec[i];
    
    return sum;
}

```

关键点：

> 该题的关键是不同的非空子串的个数，这个需要用一个 map 来筛选，防止出现重复的子串


### 523. Continuous Subarray Sum 连续的子数组和(价值)

给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

```
输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。

```

核心代码

```
public boolean checkSubarraySum(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>(){{put(0,-1);}};;
    int runningSum = 0;
    for (int i=0;i<nums.length;i++) {
        runningSum += nums[i];
        if (k != 0) runningSum %= k; 
        Integer prev = map.get(runningSum);
        if (prev != null) {
            if (i - prev > 1) return true;
        }
        else map.put(runningSum, i);
    }
    return false;
}
```

关键点：

> 本题的技巧在于累加数组 nums，然后对 k 进行取余，如果两个 i 位置取余结果相同，那么说明中间的数被 k 整除了

### 898. Bitwise ORs of Subarrays 子数组按位或操作

我们有一个非负整数数组 A。

对于每个（连续的）子数组 B = [A[i], A[i+1], ..., A[j]] （ i <= j），我们对 B 中的每个元素进行按位或操作，获得结果 A[i] | A[i+1] | ... | A[j]。

返回可能结果的数量。 （多次出现的结果在最终答案中仅计算一次。）

```
输入：[1,1,2]
输出：3
解释：
可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。
产生的结果为 1，1，2，1，3，3 。
有三个唯一值，所以答案是 3 。


```

核心代码

```
unordered_set<int> all;
unordered_set<int> setpre;
setpre.insert(A[0]);
all.insert(A[0]);

for (int i = 1; i < N; i++)
{
    unordered_set<int> setnow;
    setnow.insert(A[i]);
    all.insert(A[i]);
    for (auto j : setpre)
    {
        setnow.insert(j | A[i]);
        all.insert(j | A[i]);
    }
    
    setpre = setnow;
}

```

关键点：

> 本题也完全可以使用连续子序列的方法，但是还有可以优化的地方
> 
> 本题的优化点在于 unordered_set，节省了很多不必要的循环
> 
> 本题的亮点在于 setnow setpre all 三个 set 对象的使用，setnow 每次都加入新元素 i，每次都会将新元素 i 和0-i-1 的所有连续子序列挨个进行 | 操作，这样保证了得到了所有包含 i 元素的连续子序列。

## 子序列

小节总结：

> 不连续的子序列仍然可以使用连续子序列的方法，但是需要多加一个数组或者 map 来记录状态

### 78. 子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

```
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ret;
    vector<int> nullv;
    ret.push_back(nullv);
    if (nums.size() < 1) return ret;
    
    for (int i = 0; i < nums.size(); i++)
    {
        vector<vector<int>> tmp;
        for (int j = 0; j < ret.size(); j++)
        {
            vector<int> sub = ret[j];
            sub.push_back(nums[i]);
            
            tmp.push_back(sub);
        }
        
        ret.insert(ret.end(), tmp.begin(), tmp.end());
    }
    
    return ret;
}

```

### 90. 子集 II

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

```
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

```

核心代码

```
vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> nullv;
    res.push_back(nullv);
    if (nums.size() < 1) return res;
    
    std::sort(nums.begin(), nums.end());
    
    for (int i = 0; i < nums.size(); i++)
    {
        int count = 0;
        while (count + i < nums.size() && nums[count + i] == nums[i]) count++;
        
        int n = res.size();
        for (int j = 0; j < n; j++)
        {
            vector<int> pre = res[j];
            
            for (int k = 0; k < count; k++)
            {
                pre.push_back(nums[i]);
                res.push_back(pre);
            }
        }
        
        i += count - 1;
    }
    
    return res;
}

```

关键点

> 只要不保存 setpre，而去遍历 ret 数组，那么就会从连续子序列变为不连续子序列

### 446. Arithmetic Slices II - Subsequence 等差数列划分 II - 子序列 (个数)

数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列 (P0, P1, ..., Pk)，P 与 Q 是整数且满足 0 ≤ P0 < P1 < ... < Pk < N。

如果序列 A[P0]，A[P1]，...，A[Pk-1]，A[Pk] 是等差的，那么数组 A 的子序列 (P0，P1，…，PK) 称为等差序列。值得注意的是，这意味着 k ≥ 2。

函数要返回数组 A 中所有等差子序列的个数。

输入包含 N 个整数。每个整数都在 -231 和 231-1 之间，另外 0 ≤ N ≤ 1000。保证输出小于 231-1。

```
输入：[2, 4, 6, 8, 10]

输出：7

解释：
所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]

```

核心代码

```
int numberOfArithmeticSlices(vector<int>& A) {
    int n = A.size();
    LL ans = 0;
    vector<map<LL, int>> cnt(n);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            LL delta = (LL)A[i] - (LL)A[j];
            int sum = 0;
            if (cnt[j].find(delta) != cnt[j].end()) {
                sum = cnt[j][delta];
            }
            cnt[i][delta] += sum + 1;
            ans += sum;
        }
    }

    return (int)ans;
}

```

关键点:

> 虽然是非连续的子序列，但是只要记录了当前的状态，还是可以按照连续子序列的方式进行处理
> 
> 序列的位置 index 可能会有多个等差数列相交，此时只需要将多个等差数列的个数累加即可
> 
> 序列中存储的数据是数组的个数
> 
> 注意点：
> 
> 注意 ans+=sum，并不是累加 sum+1，原因是当前求的是等差数组的个数，一般来说应该从第三个元素上开始计算，但是本算法却是从第二个元素开始计算，因而每次都累加 sum，而且最后一个元素不会累加

### 673. Number of Longest Increasing Subsequence 最长递增子序列的个数(个数)

给定一个未排序的整数数组，找到最长递增子序列的个数。

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。

```

核心代码


```
for (int i = 0; i < N; i++) count[i] = 1;
for (int i = 1; i < N; i++)
{
    for (int j = 0; j < i; j++)
    {
        if (nums[i] > nums[j])
        {
            if (dp[j] >= dp[i])
            {
                dp[i] = dp[j] + 1;
                count[i] = count[j];
            }
            else if ((dp[j] + 1) == dp[i])
            {
                count[i] += count[j];
            }
        }
    }
}

int maxlen = 1;
for (int i = 0; i < N; i++)
{
    if (maxlen < dp[i])
        maxlen = dp[i];
}
    
int ret = 0;
for (int i = 0; i < N; i++)
{
    if (dp[i] == maxlen)
        ret += count[i];
}
```

关键点：

> 此题的难点在于递增子序列很可能会相交于同一个元素中
> 
> 因此这个时候，我们需要做的是判断当前 dp[j] 是否大于 dp[i]，如果大于，说明是更长的递增子序列，可以替换当前的 dp[i] 长度
> 
> 如果 dp[i] 与 dp[j] 正好相差 1，那么说明之前存在一个长度相等的子序列，两个子序列相交于同一个元素中，我们需要把这部分加到 i 元素上
> 
> 注意点
> 
> 本题不再是子序列的个数，因此利用的是 count[i]，初始值都是 1，只有在两个子序列重叠相交的时候，才会累加


### 300. Longest Increasing Subsequence 最长上升子序列 (价值)

给定一个无序的整数数组，找到其中最长上升子序列的长度。

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

核心代码

```
int ret = 0;
for (int i = 0; i < nums.size(); i++)
{
    for (int j = 0; j < i; j++)
    {
        if (nums[i] > nums[j])
        {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
    
    if (ret < dp[i]) ret = dp[i];
}

```

关键点：

> 本题的关键点在于 dp[i] = max(dp[i], dp[j] + 1); 这个是很多题目通用的递归公式


类似题目 1

>
>### 646. Maximum Length of Pair Chain 最长数对链

>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。

>现在，我们定义一种跟随关系，当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。

>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。

>```
输入: [[1,2], [2,3], [3,4]]
输出: 2
解释: 最长的数对链是 [1,2] -> [3,4]

>```

类似题目2

> ### 376. Wiggle Subsequence  摆动序列

>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

>```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
>```


### 873. Length of Longest Fibonacci Subsequence 最长的斐波那契子序列的长度(价值)

如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：

n >= 3
对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}
给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）

```
输入: [1,3,7,11,12,14,18]
输出: 3
解释:
最长的斐波那契式子序列有：
[1,11,12]，[3,11,14] 以及 [7,11,18] 。

```

核心代码：

```
for (int i = 0; i < M; i++)
{
    my_map[A[i]] = i;
}
    
for (int i = 0; i < M; i++)
{
    for (int j = 0; j < i; j++)
    {
        if ((A[i] - A[j]) < A[j] && my_map.count(A[i] - A[j]))
        {
            int k = my_map[A[i] - A[j]];
            dp[j][i] = dp[k][j] + 1;
            ret = ret > (dp[j][i] + 2) ? ret : (dp[j][i] + 2);
        }
    }
}
```

关键点：

> 本题的关键是 map 记录所有的元素与他们的位置 index

### 368. Largest Divisible Subset 最大整除子集（价值）

给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。

```
输入: [1,2,4,8]
输出: [1,2,4,8]

```

核心代码：

```
int maxSum = 0;
int maxIndex = -1;
for (int i = 1; i < n; i++)
{
    for (int j = i - 1; j >= 0; j--)
    {
        if (nums[i] % nums[j] == 0)
        {
            dp[i] = std::max(dp[i], dp[j] + 1);
        }
    }
    
    if (maxSum < dp[i]) {maxSum = dp[i]; maxIndex = i;}
}
        
vector<int> ret;
ret.push_back(nums[maxIndex]);
for (int i = maxIndex - 1; i >= 0; i--)
{
    if (((nums[maxIndex] % nums[i]) == 0) && dp[i] == (maxSum - 1))
    {
        maxIndex = i;
        --maxSum;
        ret.push_back(nums[i]);
    }
}

```

关键点：

> 本题的关键点在于需要回溯去求出最大的子串

### 354. 俄罗斯套娃信封问题

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

```
输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```
核心代码

```
sort(envelopes.begin(), envelopes.end(), [](pair<int, int>& pair1, pair<int, int>& pair2) {
        return (pair1.first == pair2.first) ? (pair1.second < pair2.second) : (pair1.first < pair2.first);
    });
    
    vector<int> dp(envelopes.size(), 1);
    int res = 1;
    for (int i = 0; i < envelopes.size(); i++)
    {
        for (int j = 0; j < i; j++)
        {
            if ((envelopes[i].first > envelopes[j].first) && (envelopes[i].second > envelopes[j].second))
            {
                dp[i] = std::max(dp[i], 1 + dp[j]);
                
                res = std::max(res, dp[i]);
            }
        }
    }

    return res; 
}
```

### *403. 青蛙过河

一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

```
[0,1,3,5,6,8,12,17]

总共有8个石子。
第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
第三个石子在序号为3的单元格的位置， 以此定义整个数组...
最后一个石子处于序号为17的单元格的位置。

返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。

```

核心代码

```
for (int i = 2; i < stones.size(); i++)
{
    for (int j = 1; j < i; j++)
    {
        if (dp[j].size())
        {
            int diff = stones[i] - stones[j];
            if (dp[j].find(diff - 1) != dp[j].end() || dp[j].find(diff) != dp[j].end() || dp[j].find(diff+1) != dp[j].end())
            {
                dp[i].insert(diff);
            }
        }
    }
}

```

### *514. 自由之路

视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。

给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。

最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。

旋转 ring 拼出 key 字符 key[i] 的阶段中：

您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。

```
输入: ring = "godding", key = "gd"
输出: 4
解释:
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。

```

核心代码

```
for (int i = 0; i < key.size(); i++)
{
    res = INT_MAX;
    char keyChar = key[i];
    for (int j = 0; j < ring.size(); j++)
    {
        if (keyChar == ring[j])
        {
            int tmpMin = INT_MAX;
            
            if (i == 0)
            {
                int dis = abs(j - 0);
                int dis_re = ring.size() - dis;

                tmpMin = std::min(tmpMin, std::min(dis, dis_re));
            }
            else 
            {
                for (int k = 0; k < ring.size(); k++)
                {
                    if (ring[k] == preChar)
                    {
                        int dis = abs(j - k);
                        int dis_re = ring.size() - dis;

                        tmpMin = std::min(tmpMin, std::min(dis, dis_re) + dp[i - 1][k]);
                    }
                }
            }

            dp[i][j] = tmpMin;
            res = std::min(res, tmpMin);
        }
    }
    
    preChar = keyChar;
}

```

关键点

> 本题实际上还是不连续子序列的问题，只是把序列做成了圆形而已

## 序列拆分

本节小节

> 所谓的序列拆分就是题目中要求将一个数组序列分割成为 k 份，使得若干份组合起来的价值最大或最小
> 
> 此类题目常用的方法是将 n 数组先分割为 k-1 份，然后再寻找位置 j，使得位置 j 再分割出一份，计算哪个位置 j 使得价值最高，这个时候需要三重循环
> 
> 此类问题的简单版本并不会明确 k 份，也就是可以最多分为 n 份，这个时候只需要在 n 数组中寻找位置 j 即可，只需要二重循环，并不需要 k 循环

### 343. Integer Break 整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

```

核心代码

```
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j < i; j++)
    {
        int tmp = (j * dp[i - j]) > (j * (i - j)) ? (j * dp[i - j]) : (j * (i - j)) ;
        
        dp[i] = dp[i] > tmp ? dp[i] : tmp;
    }
}

```
关键点：

> 本题是最经典的序列拆分问题，是序列拆分中不限制拆分数量的典例
> 
> 这类题目首先会计算 dp[j]，然后再将 i 分为两份，1-j,j-i，其中 dp[j] 是之前已经计算出的最优解，只需要在 j 位置分割 i 序列，就可以得到 dp[i] 最优解

### 279. Perfect Squares 完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

```
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```

核心代码

```
int numSquares(int n) {
    vector<int> memo ;  
    memo.push_back(0);
    for(int i=1; i<=n; i++) memo.push_back(i);  
    for(int i=2; i<=n; i++)  
        for(int j=1; j*j<=i; j++) {  
            memo[i] = min(memo[i], memo[i-j*j]+1);  
        }  
    return memo[n];
}

```

### 132. Palindrome Partitioning II 分割回文串 II

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

```
输入: "aab"
输出: 1
解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。

```

核心代码

```
for (int len = 0; len <= s.size(); len++)
{
    for (int i = 0; i < s.size(); i++)
    {
        int j = i + len;
        if ((j < s.size()) && (s[i] == s[j])) 
        {
            if ((len <= 1) || dp[i + 1][j - 1])
            {
                dp[i][j] = 1;
            }
        }
    }
}

vector<int> ret(s.size(), INT_MAX);
ret[0] = 0;
for (int i = 1; i < s.size(); i++) {
    ret[i] = i;
    for (int j = 0; j <= i; j++) {
        if (dp[j][i]) {
            if (j >= 1) ret[i] = std::min(ret[i], ret[j - 1] + 1);
            else ret[i] = 0;
        }
    }
}

```



### 650. 2 Keys Keyboard 只有两个键的键盘

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
Paste (粘贴) : 你可以粘贴你上一次复制的字符。
给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

```
输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。

```

核心代码

```
int minSteps(int n) {
    vector<int> dp(n+1,0x7FFFFFFF);

    dp[0] = dp[1] = 0;

    for(int i=2;i<n+1;++i){
        for(int j=1;j<i;++j){
            if(i%j==0){
                dp[i] = min(dp[i], dp[j]+i/j);
            }
        }
    }
    return dp[n];
}

```

### 813. Largest Sum of Averages 

我们将给定的数组 A 分成 K 个相邻的非空子数组 ，我们的分数由每个子数组内的平均值的总和构成。计算我们所能得到的最大分数是多少。

注意我们必须使用 A 数组中的每一个数进行分组，并且分数不一定需要是整数。

```
示例:
输入: 
A = [9,1,2,3,9]
K = 3
输出: 20
解释: 
A 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20.
我们也可以把 A 分成[9, 1], [2], [3, 9].
这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.

```

核心代码

```
for (int k = 2; k <= K; k++)
{
    for (int i = 0; i <= M; i++)
    {
        for (int j = 0; j < i; j++)
        {
            double tmp = dp[j][k - 1] + (double)((P[i] - P[j]) / (i - j));
            if (dp[i][k] < tmp)
                dp[i][k] = tmp;
        }
    }
}

```

关键点：

> 本题是序列拆分的第二种的经典类型，这种类型限制了最大的分割数
> 
> 先计算出 dp[i][k-1] 的值，也就是将 i 分割为 k-1 份，然后在 i 中再选出一个 j 位置，将 i 分割为 k 份

### *410. 分割数组的最大值

给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

```
输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

```

核心代码

```
for (int i = 2; i <= m; i++)
{
    for (int j = 0; j < nums.size(); j++)
    {
        int tmpMin = INT_MAX;
        for (int k = 0; k < j; k++)
        {
            int tmpSum = acc[j] - acc[k];
            int tmpMax = std::max(dp[i - 1][k], tmpSum);
            
            tmpMin = std::min(tmpMin, tmpMax);
        }
        
        dp[i][j] = tmpMin;
    }
}

```

### 887. 鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

```

核心代码

```
for (int k = 2; k <= K; k++)
{
    vector<int> dp2(N + 1, 0);
    int j = 1;
    for (int i = 1; i <= N; i++)
    {
        while (j < i && std::max(dp[j - 1], dp2[i - j]) > std::max(dp[j], dp2[i - j - 1]))
            j++;
        
        dp2[i] = 1 + std::max(dp[j - 1], dp2[i - j]);
    }
    
    dp = dp2;
}

```

关键点

> 扔鸡蛋有可能会摔碎，那么就是 dp[j-1][k-1] 的结果；如果没有摔碎，那么就是 dp[i-j][k] 的结果。
> 
> 两个结果中保留最大的，然后去查看哪个位置 j 的值最小。
> 
> 此题和上一题目十分相似，不同的是本题代价一直都是 1，而猜测大小的时候，代价却是 i，因此无法使用 dp[i-j][k]，而只能使用 dp[i][j][k]，幸运的是，k 可以是无限的，所以不需要进行 k 这次循环


### *629. K个逆序对数组

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

```
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。

```

核心代码

```
public int kInversePairs(int n, int k) {
    int[][] dp = new int[n + 1][k + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= k; j++) {
            if (j == 0)
                dp[i][j] = 1;
            else {
                for (int p = 0; p <= Math.min(j, i - 1); p++)
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - p]) % 1000000007;
            }
        }
    }
    return dp[n][k];
}

```

关键点

> 本题的难点在于，每次确定 i 与 j 之后，遍历 p 各个元素会更改多个 j 值
> 
> 把 i 元素放到最后 i-1 的最后一个位置，那么就会更改 dp[i][0]，放到倒数第二个位置，会更改 dp[i][1]，这样一路放下去，直到 j-p 为 0，或者一直放到第一个位置，这个时候 j=i-1
> 
> 跟一般的分割数组不同的是，i 元素放到 i-3 位置后，改变的并不是 dp[i-3][j-1]，而是 dp[i-1][j-3]

### *321. 拼接最大数

给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]

```

核心代码

```
vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
    vector<int> res;
    
    vector<vector<int>> dp1 = maxSubArray(nums1, k);
    vector<vector<int>> dp2 = maxSubArray(nums2, k);
    
    for (int i = 0; i <= k; i++)
    {
        int j = k - i;
        if (i <= nums1.size() && j <= nums2.size())
        {
            //if (i == 1)  return res;
            vector<int> compact = merge(dp1[i], dp2[j]);
            
            if (bigger(res, compact))
            {
                res = compact;
                //return res;
            }
        }
    }
    
    return res;
}
    
vector<vector<int>> maxSubArray(vector<int> nums, int k)
{
    int m = nums.size();
    k = std::min(k, m);
    
    vector<int> tmp;
    vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(nums.size(), tmp));
    vector<vector<int>> res(k + 1, tmp);
    
    for (int i = 1; i <= k; i++)
    {
        vector<int> currentMaxSub(nums.begin(), nums.begin() + i);
        for (int j = i; j < nums.size(); j++)
        {
            vector<int> preSub = dp[i - 1][j - 1];
            preSub.push_back(nums[j]);
            
            if (bigger(currentMaxSub, preSub))
            {
                currentMaxSub = preSub;
            }
            
            dp[i][j] = currentMaxSub;
        }
        
        res[i] = currentMaxSub;
    }
    
    return res;
}
    
vector<int> merge(vector<int> nums1, vector<int> nums2)
{
    vector<int> res;
    int i = 0, j = 0;
    
    while((i < nums1.size()) && (j < nums2.size()))
    {
        if (nums1[i] == nums2[j])
        {
            vector<int> temp1(nums1.begin() + i, nums1.end());
            vector<int> temp2(nums2.begin() + j, nums2.end());
            
            if (bigger(temp1, temp2)) 
            {
                res.push_back(nums2[j]);
                j++;
            }
            else 
            {
                res.push_back(nums1[i]);
                i++;
            }
        }
        else if (nums1[i] > nums2[j])
        {
            res.push_back(nums1[i]);
            i++;
        }
        else if (nums1[i] < nums2[j])
        {
            res.push_back(nums2[j]);
            j++;
        }
    }
    
    while(i < nums1.size()) 
    {
        res.push_back(nums1[i]);
        i++;
    }
    
    while(j < nums2.size())
    {
        res.push_back(nums2[j]);
        j++;
    }
    
    return res;
}
    
bool bigger(vector<int> nums1, vector<int> nums2)
{
    int i = 0, j = 0; 
    int m = nums1.size();
    int n = nums2.size();
    
    while ((i < m) && (j < n))
    {
        if (nums1[i] == nums2[j]) 
        {
            i++;j++;
        }
        else 
            break;
    }
    
    if (i == m) return true;
    if (j == n) return false;
    
    if (nums1[i] < nums2[j]) return true;
    return false;
}

```

## 序列随机选择

本章小结

> 序列随机选择类型题目一般用于求从序列中拿出元素的顺序，或者该顺序可以得到的最大值
> 
> 该种类型题目也有两种，一种是简单版本，这种版本题目中从 0-i 中取走 j 元素，接下来 0-j 与 j-i 价值并没有本质不同，这个时候只需要 dp[j] + dp[i-j] 即可，也就是二重循环即可解决
> 
> 还有一种比较麻烦，取出 j 元素后，得到的价值与 j 元素的位置相关，那么 0-j 中的价值和 i-j 中的价值就不相同，这个时候只能先进行二重循环确定 i 与 j 的范围，然后再利用 k 来扫描 i 与 j 之间的元素，也就是需要三重循环
> 
> 此外还要一种情况，是限制了选择的次数，这个时候，我们还要再来一次循环。


### 96. Unique Binary Search Trees 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

核心代码

```
dp[0] = 1;
dp[1] = 1;
    
for (int len = 2; len <= N; len++)
{
    for (int i = 1; i <= len; i++)
    {
        dp[len] += dp[i - 1] * dp[len - i];
    }
}

```
关键点

> 当题目可以随机选择序列里面任意一个元素的时候，我们可以使用本题的思路
> 
> 值得注意的是 0~i 和 i+1~len，价值上本质并没有不同，只与其个数有关，至于 i 的位置，对 dp 结果并没有任何影响

### 312. Burst Balloons 戳气球

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167

```

核心代码

```
for (int len = 1; len <= nums.size(); len++)
{
    for (int i = 0; i < nums.size(); i++)
    {
        int j = i + len - 1;
        if (j < nums.size())
        {
            for (int k = i; k <= j; k++)
            {
                int klclose = 1;
                int krclose = 1;
                int kl = 0;
                int kr = 0;
                
                if ((i - 1) >= 0) klclose = nums[i - 1];
                if ((j + 1) < nums.size()) krclose = nums[j + 1];
                if ((k - 1) >= i) kl = dp[i][k - 1];
                if ((k + 1) <= j) kr = dp[k + 1][j];
                
                dp[i][j] = std::max(dp[i][j], kl + kr + klclose * krclose * nums[k]);
            }
        }
    }
}
```
关键点

> 当题目可以随机选择任意位置 index，并且结果与其价值强相关的时候，就需要考虑本题中的算法，此时无法利用上题中的 dp[len-i]，因为 dp[len-i] 的价值并不与 dp[i][len-1] 相同
> 
> 先进行双重循环，确定 i 与 j 位置，然后利用 k 来遍历 i 与 j 之间的所有元素

### 375. Guess Number Higher or Lower II 

我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。

每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。

然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

```
n = 10, 我选择了8.

第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

游戏结束。8 就是我选的数字。

你最终要支付 5 + 7 + 9 = 21 块钱。

```

给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

核心代码

```
for (int i = 2; i <= n; i++)
{
    for (int j = i - 1; j > 0; j--)
    {
        int gtmp = INT_MAX;
        for (int k = j + 1; k < i; k++)
        {
            int tmp = max(dp[j][k - 1] + k, dp[k + 1][i] + k);
            gtmp = min(tmp, gtmp);
        }
        
        dp[j][i] = gtmp;
        if ((j + 1) == i) dp[j][i] = j;
    }
}
```

关键点：

> 本题是求解 *至少* 类题目的典型，这类题目都需要遍历 i 与 j 之间所有的 k，找到最小值 k；当计算 i-k、k-j 的时候需要去取最大值，这样才会得出至少多少

### *664. 奇怪的打印机

有台奇怪的打印机有以下两个特殊要求：

打印机每次只能打印同一个字符序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。

```
输入: "aaabbb"
输出: 2
解释: 首先打印 "aaa" 然后打印 "bbb"。

```

核心代码

```
for (int len = 2; len <= s.size(); len++)
{
    for (int i = 0; i + len - 1 < s.size(); i++)
    {
        int j = i + len - 1;
        
        dp[i][j] = len;
        for (int k = i + 1; k <= j; k++)
        {
            int tmpMin = dp[i][k - 1] + dp[k][j];
            if (s[i] == s[k])
                tmpMin = dp[i][k - 1] + dp[k + 1][j];;
            
            dp[i][j] = std::min(dp[i][j], tmpMin);
        }
    }
}

```

 