# 动态规划详解(续)
[TOC]

## 字符串比较类型

本章小结

> 字符串比较是动态规划非常典型的题目，该类题目一般都是用 i、j 两个元素来指代两个字符串上的位置，然后根据题意进行最大值最小值或者数量上的计算
> 
> 字符串的比较典型的题目是编辑距离，其中很有意思的是字符的删除，哪个字符串上的字符可以删除，那么哪个字符串的元素就可以晋升到 dp[i][j]，如果是 i 位置可以删除，那么 dp[i-1][j] 就可以直接晋升到 dp[i][j]，也就是递归公式 dp[i][j] = dp[i-1][j] 

### 392. Is Subsequence 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.

核心代码

```
while (i < M && j < N)
{
    while (s[i] != t[j] && j++ < N);
    
    if (j >= N) return false;
    i++;j++;
}

```
关键点

> 字符串比较类型的题目，通常解法都离不开定义两个变量 i 与 j，这两个变量分别指向两个字符串
> 
> 本题是最简单的情况，遍历的时候只有 i、j 指向的元素相同的时候，i 才会向前晋升一步

### 97. Interleaving String 交错字符串

给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true

```

核心代码

```

public boolean isInterleave(String s1, String s2, String s3) {
    int m = s1.length(), n = s2.length(), t = s3.length();
    if (m + n != t) {
        return false;
    }
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i > 0) {
                dp[i][j] = dp[i][j] || (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1));
            }
            if (j > 0) {
                dp[i][j] = dp[i][j] || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));
            }
        }
    }
    return dp[m][n];
}

```

### 87. Scramble String 

给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。

下图是字符串 s1 = "great" 的一种可能的表示形式。

```
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t

```

在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。

例如，如果我们挑选非叶节点 "gr" ，交换它的两个子节点，将会产生扰乱字符串 "rgeat" 。

```
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t

```

我们将 "rgeat” 称作 "great" 的一个扰乱字符串。

同样地，如果我们继续将其节点 "eat" 和 "at" 进行交换，将会产生另一个新的扰乱字符串 "rgtae" 。

```
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a


```

我们将 "rgtae” 称作 "great" 的一个扰乱字符串。

给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。

```
输入: s1 = "great", s2 = "rgeat"
输出: true

```

核心代码

```
public boolean isScramble(String s1, String s2) {
    // 初始化记忆化存储
    Map<String, Map<String, Boolean>> memo = new HashMap<>();
    return dfs(s1, s2, memo);
}

private boolean dfs(String s1, String s2, Map<String, Map<String, Boolean>> memo) {
    // 先检查是否已经计算过
    if (memo.containsKey(s1) && memo.get(s1).containsKey(s2)) {
        return memo.get(s1).get(s2);
    }
    // 判断两个字符串长度是否相等
    if (s1.length() != s2.length()) return false;
    // 判断两个字符串是否相同
    if (s1.equals(s2)) return true;
    // 判断是否包含相同种类和数量的字符
    if (!sameCharCount(s1, s2)) return false;
    
    int length = s1.length();
    // 递归检查每一种切分方式
    for (int i = 1; i < length; i++) {
        // 不交换的情况
        if (dfs(s1.substring(0, i), s2.substring(0, i), memo) && 
            dfs(s1.substring(i), s2.substring(i), memo)) {
            memo.computeIfAbsent(s1, k -> new HashMap<>()).put(s2, true);
            return true;
        }
        // 交换的情况
        if (dfs(s1.substring(0, i), s2.substring(length - i), memo) && 
            dfs(s1.substring(i), s2.substring(0, length - i), memo)) {
            memo.computeIfAbsent(s1, k -> new HashMap<>()).put(s2, true);
            return true;
        }
    }
    
    memo.computeIfAbsent(s1, k -> new HashMap<>()).put(s2, false);
    return false;
}

private boolean sameCharCount(String s1, String s2) {
    int[] letters = new int[26];
    for (int i = 0; i < s1.length(); i++) {
        letters[s1.charAt(i) - 'a']++;
        letters[s2.charAt(i) - 'a']--;
    }
    for (int i : letters) {
        if (i != 0) return false;
    }
    return true;
}


```

关键点

> 本题和其他题目都不太相同的地方在于，两个字符串比较的时候，如果两个字符串恰好顺序相反也是可以的
> 
> 更深一步来说，两个字符串可以局部某一部分顺序相反，其他部分顺序相同
> 
> 而且允许一个字符串分割为多个部分，多个部分可以颠倒顺序
> 
> 因此，我们只能将两个字符串都进行 len 长度分割，寻找两个字符串中 len 长度相同的子序列i~j,m~n
> 
> 对两个子序列，遍历每个元素 k 进行分割，观察 i~k-k~j/m~k-k+n 或者 i~k-k~j/(n-k)~n-m~(n-k) 两部分顺序是否相同


### 718. Maximum Length of Repeated Subarray 最长重复子数组

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

```
输入:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出: 3
解释: 
长度最长的公共子数组是 [3, 2, 1]。

```

核心代码

```
for (int i = 1; i <= M; i++)
{
    for (int j = 1; j <= N; j++)
    {
        if (A[i - 1] == B[j - 1])
        {
            dp[i][j] = dp[i - 1][j - 1] + 1;
            if (dp[i][j] > max) max = dp[i][j];
        }
        else
        {
            dp[i][j] = 0;
        }
    }
}

```
关键点

> 重复子数组中，子序列是连续的，因此长度和前一个元素强相关，如果前一个元素不相同，那么两个连续子序列就不是重复的
> 
> 因此只要 i-1,j-1 两个元素字符不相同，那么 dp[i][j] 就直接被设置为 0

### 115. Distinct Subsequences 不同的子序列

给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

```
输入: S = "rabbbit", T = "rabbit"
输出: 3
解释:

如下图所示, 有 3 种可以从 S 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

核心代码

```
for (int i = 0; i <= t.size(); i++)
{
    dp[0][i] = 1;
}

for (int i = 1; i <= s.size(); i++)
{
    for (int j = 1; j <= t.size(); j++)
    {
        dp[i][j] = dp[i][j - 1];
        if (s[i - 1] == t[j - 1])
        {
            dp[i][j] += dp[i - 1][j - 1];
        }
    }
}

```

关键点

> 如果例子变为 rabbitt，那么我们可以发现这个其实类似一个乘法题目，结果是 2*2
> 
> 难点在于什么条件下进行相乘
> 
> 答案是当 t 数组中 j-1 以前所有的元素，可以在 s 中找到子序列的时候，我们就可以累加 dp[i-1][j-1]，来达到相乘的作用
> 
> 第一次字符相同的时候，dp[i][j] 会继承 dp[i-1][j-1] 的个数，当以后的元素再相同的时候，我们就可以进行累加 dp[i-1][j-1]


### 72. Edit Distance 编辑距离

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

```
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

```

核心代码

```
for (int i = 1; i <= M; i++)
    for (int j = 1; j <= N; j++)
    {
        if (word1[i - 1] == word2[j - 1])
        {
            dp[i][j] = dp[i - 1][j - 1];
        }
        else  
        {
            dp[i][j] = 1 + std::min(dp[i - 1][j - 1], std::min(dp[i - 1][j], dp[i][j - 1]));
        }
    }

```

关键点：

> 编辑距离中，如果 i-1 与 j-1 元素相同，那么直接晋级，dp[i-1][j-1] 晋级为 dp[i][j]
> 
> 如果采用替换，那么也类似与 i-1 与 j-1 元素相同
> 
> 如果采用删除，如果删除 word1，那么相当于 word1 中 i 位置可以先走了一步到 i，这个时候 dp[i-1][j] 就直接晋级为 dp[i][j]
> 
> 类似的，如果删除 word2，那么 j-1 先走一步到 j，此时 dp[i][j-1] 直接晋级为 dp[i][j]

类似题目

>
### 712. Minimum ASCII Delete Sum for Two Strings 两个字符串的最小ASCII删除和
>
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。
>
```
输入: s1 = "sea", s2 = "eat"
输出: 231
解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。
在 "eat" 中删除 "t" 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。
>
>
>for (int i = 1; i <= M; i++)
{
    for (int j = 1; j <= N; j++)
    {
        if (s1[i - 1] == s2[j - 1])
        {
            dp[i][j] = dp[i - 1][j - 1];
        }
        else
        {
            dp[i][j] = min(s1[i - 1] + dp[i - 1][j], s2[j - 1] + dp[i][j - 1]);
        }
    }
}
```

>
### 583. Delete Operation for Two Strings 两个字符串的删除操作
>
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
>
```
输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
>
>
>for (int i = 1; i <= M; i++)
    for (int j = 1; j <= N; j++)
    {
        if (word1[i - 1] == word2[j - 1])
        {
            dp[i][j] = dp[i - 1][j - 1];
        }
        else
        {
            dp[i][j] = 1 + std::min(dp[i - 1][j], dp[i][j - 1]);
        }
    }
```

### *10. 正则表达式匹配

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。

```

核心代码

```
for (int j = 2; j < n; j++)
{
    if (p[j - 1] == '*' && j >= 2)
    {   
        dp[0][j] = dp[0][j - 2];
    }
}
    
for (int i = 1; i < m; i++)
{
    for (int j = 1; j < n; j++)
    {
        if ((s[i - 1] == p[j - 1]) || (p[j - 1] == '.'))
        {
            dp[i][j] = dp[i - 1][j - 1];
        }
        
        if (p[j - 1] == '*' && j >= 2)
        {
            if ((s[i - 1] == p[j - 2]) || (p[j - 2] == '.'))
                dp[i][j] |= dp[i - 1][j];
                //dp[i][j] |= dp[i][j - 1] | dp[i - 1][j - 1] | dp[i - 1][j];
            
            dp[i][j] |= dp[i][j - 2];
        }
    }
}

```

关键点：

> 虽然还是编辑距离的问题，但是本题的 * 通配符是个难点
> 
> 这个通配符可以带着前一个元素一起消失，相当于直接删除了两个元素，这个时候是 dp[i][j-2]
> 
> 如果其前一个元素相同，也可以复制一个元素，这个时候相当于 p 字符串删除一个元素，这个时候是 dp[i][j-1]
> 
> 如果相同，还可以复制二个元素，这个时候就是 dp[i-1][j-1]
> 
> 如果相同，还可以复制更多的元素，相当于在 p 字符串插入新字符，这个时候就是 dp[i-1][j]

### *44. 通配符匹配

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。

两个字符串完全匹配才算匹配成功。

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。

```

核心代码

```
dp[0][0] = 1;
        
int index = 0;
while (index < p.size() && p[index] == '*')
{
    dp[0][index + 1] = 1;
    index++;
}

for (int i = 1; i < m; i++)
{
    for (int j = 1; j < n; j++)
    {
        if (s[i - 1] == p[j - 1] | p[j - 1] == '?')
        {
            dp[i][j] = dp[i - 1][j - 1];
        }
        
        if (p[j - 1] == '*')
        {
            dp[i][j] |= dp[i - 1][j] | dp[i][j - 1];
        }
    }
}

```

### *466 统计重复个数

定义由 n 个连接的字符串 s 组成字符串 S，即 S = [s,n]。例如，["abc", 3]=“abcabcabc”。

另一方面，如果我们可以从 s2 中删除某些字符使其变为 s1，我们称字符串 s1 可以从字符串 s2 获得。例如，“abc” 可以根据我们的定义从 “abdbec” 获得，但不能从 “acbbe” 获得。

现在给出两个非空字符串 S1 和 S2（每个最多 100 个字符长）和两个整数 0 ≤ N1 ≤ 106 和 1 ≤ N2 ≤ 106。现在考虑字符串 S1 和 S2，其中S1=[s1,n1]和S2=[s2,n2]。找出可以使[S2,M]从 S1 获得的最大整数 M。

```
输入：
s1 ="acb",n1 = 4
s2 ="ab",n2 = 2

返回：
2

```

核心代码

```
for (int i = 0; i < n1; i++)
{
    for (int j = 0; j < s1.size(); j++)
    {
        if (s1[j] == s2[index])
        {
            index++;
        }
        if (index == s2.size())
        {
            index = 0;
            count += 1;
        }
    }
    
    counter[i] = count;
    indexer[i] = index;
    
    for (int k = 0; k < i; k++)
    {
        if (indexer[i] == indexer[k])
        {
            int repeat = (n1 - k - 1) / (i - k);
            int pattern_count = (counter[i] - counter[k]) * repeat;
            
            int remain_count = counter[k + (n1 - k - 1) % (i - k)];
            
            return (pattern_count + remain_count) / n2;
        }
    }
}

```


## 类石头 && 回溯动态规划算法

本章小节

> 类石头问题本质上还是回溯问题，只是带上了动态规划的一些技巧

### 877. Stone Game 石子游戏

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

```
输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。

```

核心代码

```
for (int i = 0; i < N; i++)
{
    dp[i][i] = piles[i];
}
    
for (int len = 2; len <= N; len++)
{
    for (int i = 0; i < N - 1; i++)
    {
        int j = i + len - 1;
        
        if (j < N) {
            dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
        }
        
    }
}
```


### 464. Can I Win 我能赢吗

在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。

```
输入：
maxChoosableInteger = 10
desiredTotal = 11

输出：
false

解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
```

核心代码

```
bool canWin(int target, int visited)
{
    if (m.find(visited) != m.end()) return m[visited];
    
    for (int i = 1; i <= maxn; i++)
    {
        int mask = (1 << i);
        
        if (mask & visited) continue;//have choosen
        
        if (i >= target) {m[visited] = true; return true;}
        if (canWin(target - i, mask | visited) == false)
        {m[visited] = true; return true;}
    }
    
    m[visited] = false;
    return false;
}

```

关键点

> 本题是回溯题目，回溯结束的标志是大于目标值 target
> 
> 动态规划优化了回溯算法，记录了 visited 这个值，如果遇到相同的 visited 会直接返回结果
> 
> 本题也是类石头的题目，利用了对方最优解的返回值来判断当前选择是否会赢

### 638. Shopping Offers 大礼包

在LeetCode商店中， 有许多在售的物品。

然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。

现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。

每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。

任意大礼包可无限次购买。

```
输入: [2,5], [[3,0,5],[1,2,10]], [3,2]
输出: 14
解释: 
有A和B两种物品，价格分别为¥2和¥5。
大礼包1，你可以以¥5的价格购买3A和0B。
大礼包2， 你可以以¥10的价格购买1A和2B。
你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。

```

核心代码

```
int shopping(vector<int>& price, vector<vector<int>>& special, vector<int>& needs)
{
    int res = 0;
    for (int i = 0; i < price.size(); i++)
    {
        res += price[i] * needs[i];
    }
    
    for (int i = 0; i < special.size(); i ++)
    {
        vector<int> need_clone(needs.size(), 0);
        int j = 0;
        for (j = 0 ; j < price.size(); j++)
        {
            int diff = needs[j] - special[i][j];
            if (diff < 0) break;
            
            need_clone[j] = diff;
        }
        
        if (j == price.size())
        {
            res = min(res, shopping(price, special, need_clone) + special[i][j]);
        }
    }
    
    return res;
}
```

关键点

> 本题的本质是回溯算法
> 
> 回溯算法的返回值最小是动态规划的价值，有个保底的价值是各个物品单买的总价
> 
> 这个回溯算法中需要达到的目标是个数组，在回溯的过程中，数组内任何元素超出目标，直接进行 continue


### 691. Stickers to Spell Word

我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。

你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。

如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。

拼出目标 target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。

```
["with", "example", "science"], "thehat"


3

我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。


```

核心代码

```
int helper(unordered_map<string, int>& dp, vector<vector<int>>& mp, string target) {
    if (dp.count(target)) return dp[target];
    int ans = INT_MAX, n = mp.size();
    vector<int> tar(26, 0);
    for (char c:target) tar[c-'a']++;
    // try every sticker
    for (int i = 0; i < n; i++) {
        // optimization
        //if (mp[i][target[0]-'a'] == 0) continue; 
        string s;
        // apply a sticker on every character a-z
        for (int j = 0; j < 26; j++) 
            if (tar[j]-mp[i][j] > 0) s += string(tar[j]-mp[i][j], 'a'+j);
        
        if (s != target)//如果有进展
        {
            int tmp = helper(dp, mp, s);
            if (tmp!= -1) ans = min(ans, 1+tmp);
        }
        
    }
    dp[target] = ans == INT_MAX? -1:ans;
    return dp[target];
}

```

### 808. Soup Servings 分汤

有 A 和 B 两种类型的汤。一开始每种类型的汤有 N 毫升。有四种分配操作：

- 提供 100ml 的汤A 和 0ml 的汤B。
- 提供 75ml 的汤A 和 25ml 的汤B。
- 提供 50ml 的汤A 和 50ml 的汤B。
- 提供 25ml 的汤A 和 75ml 的汤B。

当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

注意不存在先分配100 ml汤B的操作。

需要返回的值： 汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。

```
示例:
输入: N = 50
输出: 0.625
解释:
如果我们选择前两个操作，A将首先变为空。对于第三个操作，A和B会同时变为空。对于第四个操作，B将首先变为空。
所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。

```

核心代码


```
double dp(int a, int b)
{
    if (a <= 0 && b <= 0) return 0.5;
    if (a <= 0) return 1;
    if (b <= 0) return 0;
    if (memo[a][b] > 0) return memo[a][b];
    
    memo[a][b] = dp(a - 4, b) + dp(a - 3, b - 1) + dp(a - 2, b - 2) + dp(a - 1, b - 3);
    memo[a][b] *= 0.25;
    
    return memo[a][b];
}

```

## 矩阵

本章小结

> 矩阵类的题目原理比较简单，一般只需要先判断矩阵中元素 i 可以走的位置 j,k
> 
> 对于求解最高价值最低价值的题目，应该从 j,k 等位置来寻找最优的 i 位置
> 
> 对于求解路径总数的题目，应该从 i 位置计算 j,k 的位置，更简单一些。

### 221. Maximal Square 最大正方形

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

```
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4

```

核心代码

```
for (int i = 0; i < M; i++)
    for (int j = 0; j < N; j++)
    {
        dp[i][j] = 0;
        if (matrix[i][j] == '1')
        {
            dp[i][j] = 1;
            maxlen = 1;
        }
    }
    
for (int i = 1; i < M; i++)
    for (int j = 1; j < N; j++)
    {
        if (matrix[i][j] == '1')
        {
            dp[i][j] = std::min(std::min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;
            maxlen = std::max(maxlen, dp[i][j]);
        }
    }

```

### 304. Range Sum Query 2D - Immutable 二维区域和检索 - 矩阵不可变

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。

上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

```
给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -> 8
sumRegion(1, 1, 2, 2) -> 11
sumRegion(1, 2, 2, 4) -> 12

```

核心代码

```
NumMatrix(vector<vector<int>> matrix) {
    if (matrix.size() == 0 || matrix[0].size() == 0) return;
    
    dp = matrix;
    dp[0][0] = matrix[0][0];
    for (int i = 1; i < matrix.size(); i++)
    {
        dp[i][0] = dp[i - 1][0] + matrix[i][0];
    }
    
    for (int i = 1; i < matrix[0].size(); i++)
    {
        dp[0][i] = dp[0][i - 1] + matrix[0][i];
    }
    
    for (int i = 1; i < matrix.size(); i++)
        for (int j = 1; j < matrix[0].size(); j++)
        {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i][j];
        }
}
    
int sumRegion(int row1, int col1, int row2, int col2) {
    
    if (row1 == 0 && col1 == 0)
    {
        return dp[row2][col2];
    }
        
        
    if (row1 > 0 && col1 > 0)
    {
        return (dp[row2][col2] + dp[row1 - 1][col1 - 1] - dp[row1 - 1][col2] - dp[row2][col1 - 1]);
    }
    
    if (row1 == 0 && col1 >= 1)
    {
        return (dp[row2][col2] - dp[row2][col1 - 1]);
    }
    
    if (col1 == 0 && row1 >= 1)
    {
        return (dp[row2][col2] - dp[row1 - 1][col2]);
    }
}

```

### *363. 矩形区域不超过 K 的最大数值和

给定一个非空二维矩阵 matrix 和一个整数 k，找到这个矩阵内部不大于 k 的最大矩形和。

```
输入: matrix = [[1,0,1],[0,-2,3]], k = 2
输出: 2 
解释: 矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。

```

核心代码

```
for (int js = 0; js < n; js++)
{
    vector<int> sumRow(m, 0);
    for (int je = js; je < n; je++)
    {
        int currentSum = 0;
        set<int> accumulate;
        accumulate.insert(0);
        
        for (int i = 0; i < m; i++)
        {
            sumRow[i] += matrix[i][je];
            currentSum += sumRow[i];
            
            auto it = accumulate.lower_bound(currentSum - k);
            if (it != accumulate.end())
            {
                res = std::max(res, currentSum - *it);
            }
            
            accumulate.insert(currentSum);
        }
    }
}

```

关键点

> 本题实际上是计算矩形面积，正常来说计算矩形面积需要四重循环：js, je, is, ie。
> 
> 但是本题中使用了一个累计数组的一个技巧，节省了一重循环 is,ie 的循环，而是不断累计 i 元素，然后寻找 ie - is 最接近目标值的面积

### 63. Unique Paths II 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。


```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

```

核心代码


```
for (int i = 1; i < obstacleGrid[0].size(); i++)
{
    dp[0][i] = 1;
    if (obstacleGrid[0][i] == 1 || dp[0][i - 1] == 0) dp[0][i] = 0;
}
        
for (int i = 1; i < obstacleGrid.size(); i++)
{
    for (int j = 1; j < obstacleGrid[0].size(); j++)
    {
        if (obstacleGrid[i][j] == 0)
        {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
        else
        {
            dp[i][j] = 0;
        }
    }
}

```


### 64. Minimum Path Sum 最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

```

核心代码

```
for (int i = 1; i < M; i++)
{
    for (int j = 1; j < N; j++)
    {
        dp[i][j] = min(dp[i - 1][j] + grid[i - 1][j], dp[i][j - 1] + grid[i][j - 1]);
    }
}
```


### 120. Triangle 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]


```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

核心代码

```
for (int i = 1; i < N; i++)
{
    for (int j = 0; j < triangle[i].size(); j++)
    {
        if ((j - 1) >= 0 && (j) < triangle[i - 1].size())
        {
            dp[i][j] = min(dp[i - 1][j] + triangle[i - 1][j], dp[i - 1][j - 1] + triangle[i - 1][j - 1]);
        }
        else if ((j - 1) < 0)
        {
            dp[i][j] = dp[i - 1][j] + triangle[i - 1][j];
        }
        else if ((j) >= triangle[i - 1].size())
        {
            dp[i][j] = dp[i - 1][j - 1] + triangle[i - 1][j - 1];
        }
    }
}

```

### 688. Knight Probability in Chessboard  “马”在棋盘上的概率

已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 

现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 

如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。

现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。

求移动结束后，“马” 仍留在棋盘上的概率。

```
输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。


```

核心代码

```
for (; K > 0; K--)
{
    double dp2[N][N] = {0};
    for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        dp2[i][j] = 0;
    
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (abs(dp[i][j]) > 1e-8) {
                for (int m = 0; m < 8; m++)
                {
                    int tmpi = i + dr[m];
                    int tmpj = j + dc[m];

                    if (tmpi >= 0 && tmpi < N && tmpj >= 0 && tmpj < N)
                    {
                        dp2[tmpi][tmpj] += dp[i][j] / 8.0;
                    }

                }
            }
            
        }
    }
    
    memcpy(dp, dp2, sizeof(double) * N * N);
}

```

### 935. Knight Dialer 骑士拨号器

国际象棋中的骑士可以按下图所示进行移动：

这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。

每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。

你能用这种方式拨出多少个不同的号码？

因为答案可能很大，所以输出答案模 10^9 + 7。


```
输入：3
输出：46

```

核心代码

```
vector<int> dp(10, 1);
for (int i = 0; i < N - 1; i++)
{
    vector<int> cur(10, 0);
    for (int j = 0; j < 10; j++)
    {
        for (int k = 0; k < moves[j].size(); k++)
        {
            cur[moves[j][k]] += dp[j];
            cur[moves[j][k]] %= MOD;
        }
    }
    
    dp = cur;
}

```

### 576. Out of Boundary Paths 出界的路径数

给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 109 + 7 的值。

```
输入: m = 2, n = 2, N = 2, i = 0, j = 0
输出: 6


```

核心代码

```
for (int nn = 0; nn < N; nn++)
{
    long long now[m][n] = {0};
    memset(now, 0, m * n * sizeof(long long));
    for (int x = i - nn; x <= i + nn; x++)
    {
        for (int y = j - nn; y <= j + nn; y++)
        {
            if (x < 0 | y < 0 | x >= m | y >= n)
                continue;
            
            for (int d = 0; d < 4; d++)
            {
                int x1 = x + dirs[d][0];
                int y1 = y + dirs[d][1];
                if (x1 < 0 | y1 < 0 | x1 >= m | y1 >= n)
                {
                    ret = (ret + pre[x][y]) % MOD;
                }
                else
                {
                    now[x1][y1] = (now[x1][y1] + pre[x][y]) % MOD;
                }
            }
        }
    }
    
    memcpy(pre, now, m * n * sizeof(long long));
}

```

### *174. 地下城游戏

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

说明:

  - 骑士的健康点数没有上限。

  - 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

核心代码

```
int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int m = dungeon.size() - 1;
    int n = dungeon[0].size() - 1;

    dungeon[m][n] = dungeon[m][n]>0 ? 0 : dungeon[m][n];

    for (int i = m; i >= 0; i--) {
        for (int j = n; j >= 0; j--) {
            if (i < m && j < n)
                dungeon[i][j] = max(dungeon[i + 1][j], dungeon[i][j + 1]) + dungeon[i][j];
            else if (i < m)
                dungeon[i][j] = dungeon[i + 1][j] + dungeon[i][j];
            else if (j < n)
                dungeon[i][j] = dungeon[i][j + 1] + dungeon[i][j];

            dungeon[i][j] = dungeon[i][j] > 0 ? 0 : dungeon[i][j];
        }
    }

    return dungeon[0][0] > 0 ? 1 : abs(dungeon[0][0]) + 1;
}

```

关键点

> 本题有趣的地方在于为了计算骑士的最小健康点数，我们采用的时候倒着走完这个路径
> 
> 倒着走的时候，如果出现了正数健康点数，那么直接舍弃即可，这个点数对前面的路毫无用途
> 
> 倒着走的时候，如果出现了负数，那就是前面的路需要垫平的健康点数

### 741. 摘樱桃

一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
-1 表示这个格子里有荆棘，挡着你的路。
你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：

从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。

```
输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。

```

核心代码

```
for(int t = 1; t <= 2 * grid.size() - 2; t++)
{
    vector<vector<int>> dp2(grid.size(), vector<int>(grid.size(), INT_MIN));
    
    for (int i = 0; i <= n - 1; i++)
    {
        for (int j = 0; j <= n - 1; j++)
        {
            if (i < 0 || i > n - 1 || t - i < 0 || t - i > n - 1)
                continue;
            if (j < 0 || j > n - 1 || t - j < 0 || t - j > n - 1)
                continue;
            if (grid[i][t - i] == -1 || grid[j][t - j] == -1)
                continue;
            
            int val = grid[i][t - i];
            if (i != j) val += grid[j][t - j];
            
            for (int pi = i - 1; pi <= i; pi++)
            {
                for (int pj = j - 1; pj <= j; pj++)
                {
                    if (pi >= 0 && pj >= 0)
                        dp2[i][j] = std::max(dp2[i][j], dp[pi][pj] + val);
                }
            }
        }
    }
    
    dp = dp2;
}

```

关键点

> i, j 分别代表第一次去走 n 步的横坐标，和第二次回走 n 步的横坐标
> 
> 这两次的横纵坐标相加一定是 t，这样就少了一层循环
> 
> val 的计算是整个算法的核心点，代表着第一次去得到的东西，第二次就不会再得到了
> 
> 最后 dp[i][j] 的计算和正常的算法相同

## 栈类题目

### 85. Maximal Rectangle 最大矩形

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

```
输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6

```

核心代码

```
int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.size() < 1) return 0;
    int rows = matrix.size();
    int cols = matrix[0].size();
    
    vector<int> heights(cols, 0);
    int res = 0;
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            if (matrix[i][j] == '1')
            {
                if (i == 0) heights[j] = 1;
                else
                {
                    heights[j] += 1;
                }
            }
            else 
                heights[j] = 0;
        }
        
        res = std::max(res, largestRectangleArea(heights));
    }
    
    return res;
}
    
int largestRectangleArea(vector<int>& heights)
{
    int size = heights.size();
    if (size < 1) return 0;
    
    stack<int> dp;
    int res = 0;
    for (int i = 0; i < size; i++)
    {
        if (dp.empty() || (heights[i] >= heights[dp.top()])) dp.push(i);
        else
        {
            while(! dp.empty() && (heights[i] <= heights[dp.top()]))
            {
                int tmp = dp.top();
                dp.pop();
                
                if (dp.empty()) 
                    res = std::max(res, heights[tmp] * i);
                else 
                    res = std::max(res, heights[tmp] * (i - dp.top() - 1));
            }
            
            dp.push(i);
        }
    }
    
    while(! dp.empty())
    {
        int tmp = dp.top();
        dp.pop();

        if (dp.empty()) 
            res = std::max(res, heights[tmp] * size);
        else 
            res = std::max(res, heights[tmp] * (size - dp.top() - 1));
    }
    
    return res;
}

```

关键点

> 最大矩阵面积的计算使用的是累计矩阵的最大面积算法
> 
> 对于比当前元素 index 更大的值，直接放入 stack 里面
> 
> 对于比当前元素 index 小的值，需要先把 stack 之前比 index 大的值都删除出去，然后再把 index 加入 stack 里面
> 
> 删除的过程就是计算最大面积值的过程，如下图：

```
[
          |,
      |,  |,
    |,|,  |,  |,   => 
  |,|,|,  |,  |,|
]

[
        
        |,|,
    |,  |,|,  |,   => 
  |,|,  |,|,  |,|
]

[
        
       
    |,  |,|,|,     => 
  |,|,  |,|,|,  |
]
```

### 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
int trap(vector<int>& height) {
    stack<int> s;
    int res = 0;
    
    for (int i = 0; i < height.size(); i++)
    {
        if (s.empty() || height[s.top()] > height[i])
        {
            s.push(i);
        }
        else 
        {
            while (! s.empty() && height[s.top()] <= height[i])
            {
                int index = s.top();
                s.pop();
                int tmp = height[index];
                
                if (! s.empty())
                    res += (std::min(height[s.top()], height[i]) - tmp) * (i - s.top() - 1);
            }
            
            s.push(i);
        }
    }
    
    return res;
}

```

### *32. 最长有效括号

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

```

核心代码

```
for (int i = 0; i < s.size(); i++)
{
    if (s[i] == '(')
    {                
        right.push(i);
    }
    
    if ((s[i] == ')') && ! right.size())
    {
        dp[i + 1] = 0;
    }
    
    if ((s[i] == ')') && right.size())
    {
        int pre_index = right.top();
        right.pop();
        
        dp[i + 1] = i - pre_index + 1 + dp[pre_index];
        res = std::max(res, dp[i + 1]);
    }
}

```

## 比特

### 二进制中 1 的个数

```
int NumberOf1_Solution1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while (flag)
    {
        if (n & flag)
            count++;

        flag = flag << 1;
    }

    return count;
}

int NumberOf1_Solution2(int n)
{
    int count = 0;

    while (n)
    {
        ++count;
        n = (n - 1) & n;
    }

    return count;
}


```

### 338. Counting Bits 比特位计数

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

```
输入: 2
输出: [0,1,1]

```

核心代码

```
ret[0] = 0;
ret[1] = 1;
for (int i = 2; i <= num; i++)
{
    if ((i & 1) == 1)
    {
        ret[i] = ret[i - 1] + 1;
    }
    else
    {
        ret[i] = ret[i >> 1];
    }
}

```

### 600. Non-negative Integers without Consecutive Ones 不含连续 1 的非负整数(个数)


给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。

```
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。

```

核心代码：

```
int a = 1, b = 1;r[0] = 1;r[1] = 2;
for (int i = 2; i < 33; i++)
{
    int tmp = a;
    a = a + b;
    b = tmp;
    r[i] = a + b;
}

int i = 32;
for (; i >= 0; i--)
{
    if ((1 << i) & num)
        break;
}
    
int ret = 0;
int pre = 0;
for (; i >= 0; i--)
{            
    if ((1 << i) & num) {             
        ret += r[i];
        if (pre == 1)
        {
            ret -= 1;
            break;
        }
        
        pre = 1;
    }
    else 
    {
        pre = 0;
    }
}
    
return (ret + 1);
```

关键点：

> ret[i] 代表 i 位置上是 0 时，所有符合条件的个数
> 
> 当 num 的 i 位数是 1 的时候，那么将 i 位数改为 0，则必然会比 num 小，此时符合条件的个数时 ret[i]；此时由于暂时未出现连续 1 的情况，可以当前 i 位置可以保持 1，继续循环查看当前 i 位数仍然是 1 的情况下，仍然符合条件的小于 num 数
> 
> 如果当前 num 连续两个 1，那么需要先减一排除当前 num 这个数；而且由于当前位数从 1 转为 0，那么 ret[i] 中的所有数量都是小于 num 的；此外由于 i 位置无法再保持 1，所以直接结束循环即可
> 
> 当 num 的 i 位数是 0 的时候，那么我们无法保证 ret[i] 中所有的数都比 num 小，因此不会增加，而是继续循环下去
> 
> 当位数为 0 的时候，还要加上当前 num 数，所以需要加一
> 



### 89. 格雷编码

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。


```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1

```

```
vector<int> grayCode(int n) {
    vector<int> res(1, 0);
    if (n == 0) return res;
    
    for (int i = 0; i < n; i++) {
        int size = res.size();
        
        for (int j = size - 1; j >= 0; j--) {
            int num = res[j];
            num += 1<<i;
            res.push_back(res[j] + (1<<i));
        }
    }
    
    return res;
}

```

关键点

> 不断地对前面的 res 个元素的第 i 个位置设置为 1，这样就保障了与前一个元素只差一个比特

### 357. Count Numbers with Unique Digits 计算各个位数不同的数字个数

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。


```
输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。

```
核心代码

```
int ret = 0;
if (n == 0)   return 1;
if (n > 10)   return 0;
if (n == 1) return 10;
if (n == 2) return 91;
if (n > 2) ret = 91;
    
int plus = 81;
for (int i = 1; i <= n - 2; i++)
{
    if (i < 9)
    {
        plus = plus * (9 - i);
        ret = ret + plus; 
    }
}
    
return ret;

```

关键点

> 本题中求解 n 位数的个位数不同的个数，实际上通用的公式是 9 * 9 * 8 * 7 * ... * 1，因为第一个元素不能选择 0，第二个元素以后都可以选择数字 0
> 
> 唯一一个例外的就是个位数，因为个位数的第一个元素可以是 0
> 
> 本题的结果就是计算 1 位数，2 位数，3 位数 。。。 n 位数总个数之和      


### 902. 最大为 N 的数字组合

我们有一组排序的数字 D，它是  {'1','2','3','4','5','6','7','8','9'} 的非空子集。（请注意，'0' 不包括在内。）

现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 D = {'1','3','5'}，我们可以写出像 '13', '551', '1351315' 这样的数字。

返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。

```
输入：D = ["1","3","5","7"], N = 100
输出：20
解释：
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.

```
核心代码

```
for (int i = s.size() - 1; i >= 0; i--)
{
    int si = s[i] - '0';
    int index = std::lower_bound(d.begin(), d.end(), si) - d.begin();
    
    if (d[index] == si)
    {
        dp[i] += dp[i + 1] + std::pow(d.size(), s.size() - i - 1) * index;
        
    }
    else if (index >= d.size() || d[index] > si)
    {
        dp[i] += std::pow(d.size(), s.size() - i - 1) * index;
    }
}
    
for (int i = 1; i < s.size(); i++)
{
    dp[0] += std::pow(d.size(), i);
}
```

### 233. 数字 1 的个数

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

```
输入: 13
输出: 6 
解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。

```

```
int countDigitOne(int n) {
    int cnt = 0;
    
    for (long i = 1; i <= n; i *= 10) {
        int a = n / i;
        int b = n % i;
        int ai = a % 10;
        
        if (ai > 1) {
            cnt += (a / 10 + 1) * i;
        }
        else if (ai == 1) {
            cnt += (a) / 10 * i + b + 1;
        }
        else if (ai == 0) {
            cnt += a / 10 * i;
        }
    }
    
    return cnt;
}

```

### 31. 下一个排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```

核心代码

```
void nextPermutation(vector<int>& nums) {
    if (nums.size() <= 1) return;
    
    int i = nums.size() - 1;
    while (i >= 1 && nums[i - 1] >= nums[i])
        i--;
    
    if (i >= 1)
    {
        i--;
        
        int j = nums.size() - 1;
        while (j >= 0 && nums[i] >= nums[j])
            j--;
        
        swap(nums, i, j);
        
        i++;
    }
    
    std::reverse(nums.begin() + i, nums.end());
}
    
void swap(vector<int>& nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

```

关键点

> 本题的思路是先找出降序排列的子串：i-(size-1),因为这部分子串已经是最高级别的排列方式，下一步该子串应该扩大范围到 i-1 位置。
> 
> 这个时候，就要从 (i-1)-(size-1) 范围中选取一个较大的值，不一定是最大值，然后放到 i-1 位置，对 i 位置以后子串进行升序排列。

### 60. 第k个排列

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

```
输入: n = 3, k = 3
输出: "213"
```

核心代码

```
string getPermutation(int n, int k) {
    string res;
    if (n == 0) return res;
    
    vector<int> seq(n, 0);
    for (int i = 1; i <= n; i++)
        seq[i - 1] = i;
    
    dfs(seq, 0, k - 1, res);
    
    return res;
}
    
void dfs(vector<int>& seq, int start, int k, string& res) {
    if (start == (seq.size() - 1)) {
        for (int i = 0; i < seq.size(); i++)
            res += '0' + seq[i];
        
        return;
    }
    
    int base = k / fac(seq.size() - start - 1);
    int remain = k % fac(seq.size() - start - 1);
    
    std::swap(seq[start], seq[start + base]);
    std::sort(seq.begin() + start + 1, seq.end());
    
    dfs(seq, start + 1, remain, res);
}
    
int fac(int n)
{
    int result = 1;
    for(int i = 1; i <= n; i++)
        result *= i;
    
    return result;
}

```

### 数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。

```
int digitAtIndex(int index)
{
	if(index < 0)
		return -1;

	int digits = 1;
	while(true)
	{
		int numbers = countOfIntegers(digits);
		if(index < numbers * digits)
			return digitAtIndex(index, digits);

		index -= digits * numbers;
		digits++;
	}

	return -1;
}

int countOfIntegers(int digits)
{
	if(digits == 1)
		return 10;

	int count = (int) std::pow(10, digits - 1);
	return 9 * count;
}

int digitAtIndex(int index, int digits)
{
	int number = beginNumber(digits) + index / digits;
	int indexFromRight = digits - index % digits;
	for(int i = 1; i < indexFromRight; ++i)
		number /= 10;
	return number % 10;
}

int beginNumber(int digits)
{
	if(digits == 1)
		return 0;

	return (int) std::pow(10, digits - 1);
}
```


## 双向遍历

### 838. Push Dominoes 推多米诺

一行中有 N 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。

在开始时，我们同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。

同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。

如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。

就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。

给定表示初始状态的字符串 "S" 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = 'L'；如果第 i 张多米诺骨牌被推向右边，则 S[i] = 'R'；如果第 i 张多米诺骨牌没有被推动，则 S[i] = '.'。

返回表示最终状态的字符串。

```
输入：".L.R...LR..L.."
输出："LL.RR.LLRRLL.."

```

核心代码

```
for (int i = 0; i < n; i++) {L[i] = -1; R[i] = -1;}
        
int l = -1, r = -1;
for (int i = 0; i < n; i++)
{
    if (dominoes[i] == 'R') r = 0;
    if (dominoes[i] == 'L') r = -1;
    
    if (r >= 0) R[i] = r++;
}
for (int i = n - 1; i >= 0; i--)
{
    if (dominoes[i] == 'L') l = 0;
    if (dominoes[i] == 'R') l = -1;
    
    if (l >= 0) L[i] = l++;
}
    
for (int i = 0; i < n; i++)
{               
    if (dominoes[i] == '.')
    {
        if (L[i] > R[i] && R[i] != -1) 
            dominoes[i] = 'R';
        
        if (L[i] > R[i] && R[i] == -1) 
            dominoes[i] = 'L';
    
        if (L[i] < R[i] && L[i] != -1)
            dominoes[i] = 'L';
        
        if (L[i] < R[i] && L[i] == -1)
            dominoes[i] = 'R';
    }
}

```

关键点

> 从左到右遍历，计算 R[i] 的各个元素价值
> 
> 遍历的过程中，R[i] 初始值为 -1，当遇到 'R' 字符的时候，被置为 0，并开始递增；当遇到 'L' 字符的时候，被置为 -1，结束递增
> 
> 从右到左遍历也是相同
> 
> 最终计算的时候，如果 L[i] > R[i] && R[i] == -1，代表 i 元素位于最左端；类似地 L[i] < R[i] && L[i] == -1，说明 i 元素在最右端

### 764. Largest Plus Sign 最大加号标志

在一个大小在 (0, 0) 到 (N-1, N-1) 的2D网格 grid 中，除了在 mines 中给出的单元为 0，其他每个单元都是 1。网格中包含 1 的最大的轴对齐加号标志是多少阶？返回加号标志的阶数。如果未找到加号标志，则返回 0。

一个 k" 阶由 1 组成的“轴对称”加号标志具有中心网格  grid[x][y] = 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。下面给出 k" 阶“轴对称”加号标志的示例。注意，只有加号标志的所有网格要求为 1，别的网格可能为 0 也可能为 1。

```
输入: N = 5, mines = [[4, 2]]
输出: 2
解释:

11111
11111
11111
11111
11011

在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。

```

核心代码

```
for (int i = 0; i < N; i++)
{
    count = 0;
    for (int j = 0; j < N; j++)
    {
        count = banned.count(i * N + j) ? 0 : (count + 1);
        dp[i][j] = count;
    }
    
    count = 0;
    for (int j = N - 1; j >= 0; j--)
    {
        count = banned.count(i * N + j) ? 0 : (count + 1);
        dp[i][j] = min(dp[i][j], count);
    }
}
    
for (int j = 0; j < N; j++)
{
    count = 0;
    for (int i = 0; i < N; i++)
    {
        count = banned.count(i * N + j) ? 0 : (count + 1);
        dp[i][j] = min(dp[i][j], count);
    }
    
    count = 0;
    for (int i = N - 1; i >= 0; i--)
    {
        count = banned.count(i * N + j) ? 0 : (count + 1);
        dp[i][j] = min(dp[i][j], count);
        if (ret < dp[i][j]) ret = dp[i][j];
    }
}

```

## 其他

### 264. Ugly Number II 丑数 II

编写一个程序，找出第 n 个丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

```

核心代码

```
int factor2 = 2, factor3 = 3, factor5 = 5;
int index2 = 0, index3 = 0, index5 = 0;
    
for (int i = 1; i < n; i++)
{
    int min = std::min(std::min(factor2, factor3), factor5);
    ugly[i] = min;
    
    if (min == factor2)
    {
        factor2 = 2 * ugly[++index2];
    }
    
    if (min == factor3)
    {
        factor3 = 3 * ugly[++index3];
    }
    
    if (min == factor5)
    {
        factor5 = 5 * ugly[++index5];
    }
}

```
关键点

> 本题的思路类似于三个运动员一起散步
> 
> 谁最小，谁向前走一步

### 517. 超级洗衣机

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。

在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。

给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。

```
输入: [1,0,5]

输出: 3

解释: 
第一步:    1     0 <-- 5    =>    1     1     4
第二步:    1 <-- 1 <-- 4    =>    2     1     3    
第三步:    2     1 <-- 3    =>    2     2     2  

```

核心代码

```
for (int i = 0; i < machines.size(); i++)
{
    int l = (i >= 1) ? (i * avg - sum[i - 1]) : 0;
    int r = (machines.size() - i - 1) * avg - (sum[machines.size() - 1] - sum[i]);
    
    if (l > 0 && r > 0)
    {
        res = std::max(res, abs(l) + abs(r));
    }
    else 
    {
        res = std::max(res, std::max(abs(l), abs(r)));
    }
}

```

关键点

> 本题的规律就是一个元素 index，只有波峰才会将差值相加，因为 index 元素没有办法向左右两个方向同时推送
> 
> 否则，只需要左右两个方向的最大值即可，因为序列可以同时向左或者向右推送，加入左 -3，右 5，这个时候只需要向右推送 5 次，在推送第三次的时候，左边已经被填平

### 787. Cheapest Flights Within K Stops  K 站中转内最便宜的航班

有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。

```

示例 1:
输入: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
输出: 200
解释: 
城市航班图如下


从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。

```

核心代码

```
for (int i = 0; i < K + 2; i++) 
    for (int j = 0; j < n; j++)
        dp[i][j] = INT_MAX;
   
for (int i = 0; i < K + 2; i++) 
    dp[i][src] = 0;
    
for (int i = 1; i < K + 2; i++)
{
    for (int j = 0; j < flights.size(); j++)
    {
        int u = flights[j][0];
        int v = flights[j][1];
        int weight = flights[j][2];
        if (dp[i - 1][u] != INT_MAX)
        {
            
            dp[i][v] = std::min(dp[i][v], dp[i - 1][u] + weight);
        }
        
    }
}

```

关键点

> 本题是标准的最短路径问题，也是标准的动态规划问题
> 
> 该算法就是不断的加大与源头 src 的距离半径，由于第一次加大半径是 src 与 v 节点相连接，并没有中间中转，因此需要 k+1 次循环，这个是和标准的最短路径不同的地方。
> 














